.. Quick start guide to the API, started 24/10/2017

API quick start
***************

Your best start for developing scripts which use HiPERCAM data is probably to
look at whichever one of the existing scripts seems closest to your task.
But to give a bit more backgrounds, here are a few basics to start off.

.. contents:: :local:

HiPERCAM hcm files and MCCD objects
===================================

The pipeline stores individual multi-CCD exposures as :class:`MCCD` objects in
memory.  These contain all windows of all CCDs. e.g. for HiPERCAM itself,
there will be 5 CCDs, each with either 4 or 8 windows of data. They quickly
allow access to the data. Thus given an :class:`MCCD` objects called 'mccd',
the following lines return first a single CCD labelled '2', then a window of
that CCD labelled 'E1', then a 2D numpy array containing the data of that window::

   ccd  = mccd['2']
   wind = ccd['E1']
   data = wind.data

At this point you have direct access to the data. e.g. The value of the pixel
at (x,y) = (10,20) can be printed as::

   print(data[20,10])

Note the C-style ordering, with Y coming first, and that the pixel indices are
C-style 0-offset; apologies to FORTRAN devotees. :class:`MCCD` objects are
derived from dictionaries (more strictly :class:`OrderedDict` objects), and
are keys on string labels assigned to the CCDs they contain. For HiPERCAM data
they are labelled '1', '2', '3', '4' and '5' for the ugriz arms. A statement
such as ``ccd = mccd['2']`` returns CCD '2' as a :class:`CCD` object which is
also dictionary-like so that ``ccd['E1']`` returns window 'E1' as a
:class:`Windat` object. It is worth persuing the methods of all these classes.

How does one get an :class:`MCCD` in the first place? One way is to read it in from a
file using the class method
hipercam.MCCD.read as follows::

   import hipercam as hcam

   mccd = hcam.MCCD.read('myfile.hcm')

assuming that there is some pre-written file 'myfile.hcm', as generated by
e.g. grab. If we do something to 'mccd' and want to save it then::

   mccd.write('mynewfile.hcm')

or::

   mccd.write('mynewfile.hcm',True)

if we don't mind over-writing a pre-existing file, will do the job. "hcm" is
the standard extension the pipeline uses when saving :class:`MCCD` objects to
disk, but these files are in fact FITS files and can be looked at with
standard tools such as "fv". The extension hightlights that they are a
particular style of FITS files and keeps them separate from the raw data comes
with the extension '.fits' (see below). Here is a script to subtract two files
and save the result::

   import hipercam as hcam

   mccd1 = hcam.MCCD.read('input1.hcm')
   mccd2 = hcam.MCCD.read('input2.hcm')

   mccd1 -= mccd2

   mccd1.write('output.hcm')

This will subtract the files CCD by CCD and window by window and can easily
fail if the formats don't match, but serves to show that the API allows one
to quickly make progress with HiPERCAM format files.

Dealing with raw data files
===========================

You may prefer to deal directly with the raw data files, although be aware of
the slight risk of corruption if you do so. These have names like
'run0034.fits'. They are FITS files, but are not directly usable as the data
is somewhat scrambled within a 3D FITS "cube" owing to the constraints of
continually adding to FITS during data acquisition. To minimize the risk, the
pipeline has no mechanism to write raw files, and does not use the extension
'.fits' for any of the various files it produces. If you want to modify data,
you need to write out lists of hcm files.

Here is an example of subtracting the median values from all the windows of
 all CCDs of a run::

.. code-block:: python
   :linenos:

   import hipercam as hcam

   input_name = 'run0034'

   with hcam.HcamDiskSpool(input_name) as spool:

       for n, mccd in enumerate(spool):

           # subtract median from each window of each CCD
           for ccd in mccd.values():
               for wind in ccd.values():
                   wind -= wind.median()

          output_name = '{:s}_{:3d}.hcm'.format(input_name,n+1)
          mccd.write(output_file)

Line 1 imports the pipeline software. Line 5 defines an iterator in
Python-speak, 'spool', that can be repeatedly called in a loop to return the
frames successively as :class:`MCCD` objects (line 7) labelled 'mccd'. It is
called using the 'with' statement in a way that allows the file to be
automatically closed when we are done (in Python jargon, it's a "context
manager" as well as an iterator). Lines 10 to 12 subtract the medians, while
lines 14 and 15 write out the files to disk with integer labels to distinguish
the multiple frames that might be generated.

:class:`HcamDiskSpool` is one of 5 similar iterable context managers to return
data. Another useful one is :class:`HcamListSpool` which can be attached to a
file list to return each file as an :class:`MCCD`. Others source data from
servers for both HiPERCAM and ULTRA(CAM|SPEC). Several of the standard
HiPERCAM scripts (rtplot, reduce, grab for example) use a special method
'data_source' to return any one of these 5 types. For instance these lines
are extracted from 'rtplot'::

    with hcam.data_source(source, run, first) as spool:

        for mccd in spool:

'source' here takes values 'hl', 'hs', 'hf', 'ul', or 'us' to distinguish the
type of the source of data. 'run' is the run or in the case of a file list,
the file name, while first is the number of the first frame to return. This
provides uniform access code to the different types of data.

Command line inputs
===================

The pipeline uses a style of command-line inputs derived from STARLINK
routines that is distinct from the usual UNIX-style command-line options. The
first key difference is that if you don't enter values on the command-line
itself, you will be prompted for most of them, although a '\' during prompted
input or '\\' on the command-line will curtail such prompting.  The second is
that commands have a memory: your entries are written to disk files to act as
defaults the next time round. This has great benefits in reducing the amount
of typing. If you want to write scripts that follow the same convention then
you should look at ``hipercam.cline``.
