import copy
import os
import signal
import sys

import numpy as np
from astropy.stats import sigma_clip
from astropy.wcs import wcs
from reproject import reproject_adaptive, reproject_exact, reproject_interp
from trm import cline
from trm.cline import Cline

import hipercam as hcam

try:
    import bottleneck as bn

    meanfunc = bn.nanmean
    medianfunc = bn.nanmedian
except ImportError:
    meanfunc = np.nanmean
    medianfunc = np.nanmedian

__all__ = [
    "shiftadd",
]


class CleanUp:
    """
    Context manager to handle temporary files
    """

    def __init__(self, flist, temp):
        self.flist = flist
        self.temp = temp

    def _sigint_handler(self, signal_received, frame):
        print("\naverun aborted")
        sys.exit(1)

    def __enter__(self):
        signal.signal(signal.SIGINT, self._sigint_handler)

    def __exit__(self, type, value, traceback):
        if self.temp:
            with open(self.flist) as fp:
                for line in fp:
                    os.remove(line.strip())
            os.remove(self.flist)
            print("temporary files removed")


def new_wcs(wbase, dx, dy):
    """
    Shifts an image by dx, dy
    """
    wnew = copy.deepcopy(wbase)
    wnew.wcs.crpix = [-dx, -dy]
    return wnew


def wcs_from_header(mccd):
    """
    Try and make a WCS obect from the header of an MCCD

    If this routine fails it will return a non-celestial WCS
    that still allows stacking of images, but not using the
    exact reprojection method.
    """
    header = mccd.head

    # find pixel limits of all windows
    for cnam, ccd in mccd.items():
        for n, wind in enumerate(ccd.values()):
            if n == 0:
                llxmin = wind.llx
                llymin = wind.lly
                urxmax = wind.urx
                urymax = wind.ury
                xbin = wind.xbin
                ybin = wind.ybin
            else:
                # Track overall dimensions
                llxmin = min(llxmin, wind.llx)
                llymin = min(llymin, wind.lly)
                urxmax = max(urxmax, wind.urx)
                urymax = max(urymax, wind.ury)

    ZEROPOINT = 209.7  # rotator zeropoint
    SCALE = 0.081  # pixel scale, "/unbinned pixel

    # ra, dec in degrees at rotator centre
    ra = header["RADEG"]
    dec = header["DECDEG"]

    # position angle, degrees
    pa = header["INSTRPA"] - ZEROPOINT
    x0, y0 = (
        (1020.0 - llxmin + 1) / xbin,
        (524.0 - llymin + 1) / ybin,
    )
    w = wcs.WCS(naxis=2)
    w.wcs.crpix = [x0, y0]
    w.wcs.crval = [ra, dec]
    cpa = np.cos(np.radians(pa))
    spa = np.sin(np.radians(pa))
    cd = np.array([[xbin * cpa, ybin * spa], [-xbin * spa, ybin * cpa]])
    cd *= SCALE / 3600
    w.wcs.cd = cd
    w.wcs.ctype = ["RA---TAN", "DEC--TAN"]
    w.wcs.cunit = ["deg", "deg"]
    return w


def shiftadd(args=None):
    """
    ``shiftadd [source]  (run first last twait tmax | flist) trim ([ncol
    nrow]) bias dark flat fmap (fpair [nhalf rmin rmax]) [overwrite]

    Averages images from a run using mean combination, but shifting each
    image based on the positions of stars.

    Parameters:

        source : str [hidden]
           Data source, five options:

              | 'hs' : HiPERCAM server
              | 'hl' : local HiPERCAM FITS file
              | 'us' : ULTRACAM server
              | 'ul' : local ULTRACAM .xml/.dat files
              | 'hf' : list of HiPERCAM hcm FITS-format files

           'hf' is used to look at sets of frames generated by 'grab'
           or converted from foreign data formats. The standard
           start-off default for ``source`` can be set using the
           environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
           :code:`export HIPERCAM_DEFAULT_SOURCE="us"` would ensure it
           always started with the ULTRACAM server by default. If
           unspecified, it defaults to 'hl'.

        run : str [if source ends 's' or 'l']
           run number to access, e.g. 'run034'

        flist : str [if source ends 'f']
           name of file list

        first : int [if source ends 's' or 'l']
           exposure number to start from. 1 = first frame ('0' is
           not supported).

        last : int [if source ends 's' or 'l']
           last exposure number must be >= first, or 0 for the lot

        rfilen : str
            name of reduce file.

        refccd : str
            reference CCD to use for finding offsets

        fthresh : float
            maximum FWHM to allow, in unbinned pixels on the reference CCD.
            frames with FWHM > fthresh will be ignored.

        reprmethod : str
            Method to use for reprojecting the data. Options are 'interp',
            'adaptive' and 'exact'. 'interp' is the fastest but does not
            conserve flux. 'adaptive' is slower but conserves flux. 'exact'
            is the slowest but most accurate. 'adaptive' is the default.
            See https://reproject.readthedocs.io for details.

        reprorder : int [if reprmethod is 'interp'; hidden]
            Order of interpolation to use. 0 is nearest neighbour, 1 is
            bilinear, 2 is quadratic, 3 is cubic. 1 is the default.

        consflux : bool [if reprmethod is 'adaptive'; hidden]
            conserve flux when reprojecting. True is the default.

        reprkernel : str [if reprmethod is 'adaptive'; hidden]
            The averaging kernel to use. Allowed values are 'Hann' and 'Gaussian'.
            The Gaussian kernel produces better photometric accuracy and stronger
            anti-aliasing at the cost of some blurring (on the scale of a few
            pixels). If not specified, the Gaussain kernel is used by default.

        kwidth : float [if reprmethod is 'adaptive'; hidden]
            The width of the kernel in pixels, expressed as the standard
            deviation of the Gaussian kernel. Is not used for the Hann kernel.
            Reducing this width may introduce photometric errors or leave input
            pixels under-sampled, while increasing it may improve the degree of
            anti-aliasing but will increase blurring of the output image.
            If this width is changed from the default, a proportional change
            should be made to the value of regwidth to maintain an
            equivalent degree of photometric accuracy. Default is 1.3.

        regwidth : float [if reprmethod is 'adaptive'; hidden]
            The width in pixels of the output-image region which, when
            transformed to the input plane, defines the region to be sampled
            for each output pixel.  Used only for the Gaussian kernel, which
            otherwise has infinite extent. This value sets a trade-off between
            accuracy and computation time, with better accuracy at higher values.
            The default value of 4, with the default kernel width,
            should limit the most extreme errors to less than one percent.
            Higher values will offer even more photometric accuracy.

        twait : float [if source ends 's' or 'l'; hidden]
           time to wait between attempts to find a new exposure, seconds.

        tmax : float [if source ends 's' or 'l'; hidden]
           maximum time to wait between attempts to find a new exposure,
           seconds.

        trim : bool
           True to trim columns and/or rows off the edges of windows nearest
           the readout. Useful for ULTRACAM particularly.

        ncol : int [if trim, hidden]
           Number of columns to remove (on left of left-hand window, and right
           of right-hand windows)

        nrow : int [if trim, hidden]
           Number of rows to remove (bottom of windows)

        bias : str
           Name of bias frame to subtract, 'none' to ignore.

        dark : str
           Name of dark frame to subtract, 'none' to ignore.

        flat : str
           Name of flat field to divide by, 'none' to ignore.

        fmap : str
           Name of fringe map (see e.g. `makefringe`), 'none' to ignore.

        fpair : str [if fmap is not 'none']
           Name of fringe pair file (see e.g. `setfringe`). Required if
           a fringe map has been specified.

        nhalf : int [if fmap is not 'none', hidden]
           When calculating the differences for fringe measurement,
           a region extending +/-nhalf binned pixels will be used when
           measuring the amplitudes. Basically helps the stats.

        rmin : float [if fmap is not 'none', hidden]
           Minimum individual ratio to accept prior to calculating the overall
           median in order to reduce the effect of outliers. Although all ratios
           should be positive, you might want to set this a little below zero
           to allow for some statistical fluctuation.

        rmax : float [if fmap is not 'none', hidden]
           Maximum individual ratio to accept prior to calculating the overall
           median in order to reduce the effect of outliers. Probably typically
           < 1 if fringe map was created from longer exposure data.

        method : str [hidden, defaults to 'm']
           'm' for median, 'c' for clipped mean. See below for pros and cons.

        sigma : float [hidden; if method == 'c']
           With clipped mean combination, pixels that deviate by more than
           sigma RMS from the mean are kicked out. This is carried out in an
           iterative manner. sigma <= 0 implies no rejection, just a straight
           average. sigma=3 is typical.

        maxiters : int [hidden; if method == 'c']
            Maximum number of iterations in sigma clipping. 3 is typical.

        overwrite : bool [hidden]
           overwrite any pre-existing output files

        output  : string
           output file
    """
    command, args = cline.script_args(args)
    # get the inputs
    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:
        # register parameters
        cl.register("source", Cline.GLOBAL, Cline.HIDE)
        cl.register("run", Cline.GLOBAL, Cline.PROMPT)
        cl.register("first", Cline.LOCAL, Cline.PROMPT)
        cl.register("last", Cline.LOCAL, Cline.PROMPT)
        cl.register("rfilen", Cline.LOCAL, Cline.PROMPT)
        cl.register("refccd", Cline.LOCAL, Cline.PROMPT)
        cl.register("fthresh", Cline.LOCAL, Cline.HIDE)

        cl.register("reprmethod", Cline.LOCAL, Cline.PROMPT)
        cl.register("reprorder", Cline.LOCAL, Cline.HIDE)
        cl.register("consflux", Cline.LOCAL, Cline.HIDE)
        cl.register("reprkernel", Cline.LOCAL, Cline.HIDE)
        cl.register("kwidth", Cline.LOCAL, Cline.HIDE)
        cl.register("regwidth", Cline.LOCAL, Cline.HIDE)

        cl.register("twait", Cline.LOCAL, Cline.HIDE)
        cl.register("tmax", Cline.LOCAL, Cline.HIDE)
        cl.register("trim", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ncol", Cline.GLOBAL, Cline.HIDE)
        cl.register("nrow", Cline.GLOBAL, Cline.HIDE)
        cl.register("flist", Cline.LOCAL, Cline.PROMPT)
        cl.register("bias", Cline.LOCAL, Cline.PROMPT)
        cl.register("dark", Cline.GLOBAL, Cline.PROMPT)
        cl.register("flat", Cline.GLOBAL, Cline.PROMPT)
        cl.register("fmap", Cline.GLOBAL, Cline.PROMPT)
        cl.register("fpair", Cline.GLOBAL, Cline.PROMPT)
        cl.register("nhalf", Cline.GLOBAL, Cline.HIDE)
        cl.register("rmin", Cline.GLOBAL, Cline.HIDE)
        cl.register("rmax", Cline.GLOBAL, Cline.HIDE)
        cl.register("method", Cline.LOCAL, Cline.HIDE)
        cl.register("sigma", Cline.LOCAL, Cline.HIDE)
        cl.register("maxiters", Cline.LOCAL, Cline.HIDE)
        cl.register("overwrite", Cline.LOCAL, Cline.HIDE)
        cl.register("output", Cline.LOCAL, Cline.PROMPT)

        # get inputs
        default_source = os.environ.get("HIPERCAM_DEFAULT_SOURCE", "hl")
        source = cl.get_value(
            "source",
            "data source [hs, hl, us, ul, hf]",
            default_source,
            lvals=("hs", "hl", "us", "ul", "hf"),
        )
        # set a flag
        server_or_local = source.endswith("s") or source.endswith("l")

        if server_or_local:
            resource = cl.get_value("run", "run name", "run005")

            first = cl.get_value("first", "first frame to average", 1, 1)
            last = cl.get_value("last", "last frame to average", first, 0)

            twait = cl.get_value(
                "twait", "time to wait for a new frame [secs]", 1.0, 0.0
            )
            tmax = cl.get_value(
                "tmax", "maximum time to wait for a new frame [secs]", 10.0, 0.0
            )

        else:
            resource = cl.get_value(
                "flist", "file list", cline.Fname("files.lis", hcam.LIST)
            )
            first = 1

        rfilen = cl.get_value(
            "rfilen", "reduce file", cline.Fname("reduce.red", hcam.RED)
        )

        REF_CCD = cl.get_value("refccd", "reference CCD to use to measure offsets", "3")

        fthresh = cl.get_value(
            "fthresh",
            "maximum FWHM to allow, -ve to accept all",
            -1.0,
        )

        reprmethod = cl.get_value(
            "reprmethod",
            "Method to use for reprojecting the data",
            "adaptive",
            lvals=("interp", "adaptive", "exact"),
        )
        if reprmethod == "interp":
            reprorder = cl.get_value(
                "reprorder",
                "Order of interpolation to use (0=nearest neighbour)",
                1,
                0,
            )
        elif reprmethod == "adaptive":
            consflux = cl.get_value("consflux", "conserve flux when reprojecting", True)
            reprkernel = cl.get_value(
                "reprkernel",
                "The averaging kernel to use",
                "Gaussian",
                lvals=("Hann", "Gaussian"),
            )
            if reprkernel == "Gaussian":
                kwidth = cl.get_value(
                    "kwidth",
                    "The width of the kernel in pixels",
                    1.3,
                    0.0,
                )
                regwidth = cl.get_value(
                    "regwidth",
                    "The width in pixels of the output-image region",
                    4,
                    0.0,
                )

        trim = cl.get_value("trim", "do you want to trim edges of windows?", True)
        if trim:
            ncol = cl.get_value("ncol", "number of columns to trim from windows", 0)
            nrow = cl.get_value("nrow", "number of rows to trim from windows", 0)

        # bias frame (if any)
        bias = cl.get_value(
            "bias",
            "bias frame ['none' to ignore]",
            cline.Fname("bias", hcam.HCAM),
            ignore="none",
        )

        # dark frame (if any)
        dark = cl.get_value(
            "dark",
            "dark frame ['none' to ignore]",
            cline.Fname("dark", hcam.HCAM),
            ignore="none",
        )

        # flat field frame (if any)
        flat = cl.get_value(
            "flat",
            "flat field frame ['none' to ignore]",
            cline.Fname("flat", hcam.HCAM),
            ignore="none",
        )

        # fringe file (if any)
        fmap = cl.get_value(
            "fmap",
            "fringe map ['none' to ignore]",
            cline.Fname("fmap", hcam.HCAM),
            ignore="none",
        )

        if fmap is not None:
            fpair = cl.get_value(
                "fpair", "fringe pair file", cline.Fname("fringe", hcam.FRNG)
            )
            nhalf = cl.get_value(
                "nhalf", "half-size of fringe measurement regions", 2, 0
            )
            rmin = cl.get_value("rmin", "minimum fringe pair ratio", -0.2)
            rmax = cl.get_value("rmax", "maximum fringe pair ratio", 1.0)

        cl.set_default("method", "m")
        method = cl.get_value(
            "method", "c(lipped mean), m(edian)", "c", lvals=("c", "m")
        )

        if method == "c":
            sigma = cl.get_value("sigma", "number of RMS deviations to clip", 3.0)
            maxiters = cl.get_value(
                "maxiters", "maximum number of clipping iterations", 3
            )

        overwrite = cl.get_value(
            "overwrite", "overwrite any pre-existing files on output", False
        )
        outfile = cl.get_value(
            "output",
            "output file",
            cline.Fname(
                "hcam",
                hcam.HCAM,
                cline.Fname.NEW if overwrite else cline.Fname.NOCLOBBER,
            ),
        )

    # inputs done with. Now do the work with 'grab' and 'combine'
    use_grab = (
        server_or_local
        or bias is not None
        or dark is not None
        or flat is not None
        or fmap is not None
    )
    if use_grab:
        print("\nCalling 'grab' ...")

        # Build argument list
        args = [None, "prompt", source, "yes", resource]
        if server_or_local:
            args += [str(first), str(last), str(twait), str(tmax)]
        if trim:
            args += ["yes", str(ncol), str(nrow)]
        else:
            args += ["no"]
        args += [
            "none" if bias is None else bias,
            "none" if dark is None else dark,
            "none" if flat is None else flat,
        ]
        if fmap is None:
            args += ["none", "f32"]
        else:
            args += [fmap, fpair, str(nhalf), str(rmin), str(rmax), "false", "f32"]

        resource = hcam.scripts.grab(args)

    # at this point 'resource' is a list of files, no matter the input
    # method.
    rfile = hcam.reduction.Rfile.read(rfilen)
    read = None
    ccdwin = {}  # holds the window name for each Aperture/CCD combo
    offsets = []
    fwhm_values = []
    store = {}
    xoff, yoff = 0.0, 0.0
    with CleanUp(resource, use_grab):
        files = open(resource).readlines()

        print("calculating pixel shifts")
        for iframe, fname in enumerate(files):
            fname = str(fname.strip())
            print("Fitting apertures to frame", iframe + 1)
            mccd = hcam.MCCD.read(fname)

            if read is None:
                read, gain, ok = hcam.reduction.initial_checks(mccd, rfile)

            # loop over CCDs
            cnam = REF_CCD
            ccd = mccd[cnam]

            # skip frames with no data
            if not ccd.is_data():
                continue

            # initialise store of shifts for this CCD
            if cnam not in store:
                store[cnam] = {"mfwhm": -1.0, "mbeta": -1.0}

            # first time around, find which window contains each aperture
            if cnam not in ccdwin:
                ccdwin[cnam] = {}
                for apnam, aper in rfile.aper[cnam].items():
                    for wnam, wind in mccd[cnam].items():
                        if wind.distance(aper.x, aper.y) > 0:
                            ccdwin[cnam][apnam] = wnam
                            break
                        else:
                            ccdwin[cnam][apnam] = None

            hcam.reduction.moveApers(
                cnam,
                mccd[cnam],
                mccd[cnam],
                read[cnam],
                gain[cnam],
                ccdwin[cnam],
                rfile,
                store[cnam],
            )

            # store the mean FWHM
            fwhm_values.append(store[cnam]["mfwhm"])

            # calculate the shifts only using reference stars
            dx = np.mean(
                [
                    store[cnam][apnam]["dx"]
                    for apnam in rfile.aper[cnam]
                    if rfile.aper[cnam][apnam].ref
                ]
            )
            dy = np.mean(
                [
                    store[cnam][apnam]["dy"]
                    for apnam in rfile.aper[cnam]
                    if rfile.aper[cnam][apnam].ref
                ]
            )
            xoff += dx
            yoff += dy
            offsets.append((xoff, yoff))

        # offsets are now defined w.r.t to the positions in the
        # aperture file for first image, and then w.r.t to
        # previous file for subsequent images. For each CCD,
        # we should center the offsets on 0,0. This minimises the
        # risks of having unsampled pixels in the full frame data
        offsets = np.array(offsets)
        offsets -= offsets.mean(axis=0)

        output_mccd = hcam.MCCD.read(str(files[0].strip()))
        cnames = sorted(list(output_mccd.keys()))

        for cnam in cnames:
            print(f"stacking CCD {cnam}")

            try:
                # make real celestial WCS from header
                orig_wcs = wcs_from_header(output_mccd)
            except:
                # fallback to basic WCS which can be used
                # for any method except 'exact'
                # start with basic WCS, CRDELT1, no offsets
                orig_wcs = wcs.WCS(naxis=2)

            arrs = []
            nframes_used = 0
            header_string = "nframes="
            for ifile, fname in enumerate(files):
                fname = str(fname.strip())
                mccd = hcam.MCCD.read(fname)
                ccd = mccd[cnam]
                if not ccd.is_data():
                    continue

                # skip if FWHM is above threshold
                if fthresh > 0 and fwhm_values[ifile] > fthresh:
                    print(
                        f"skipping frame {ifile+1} (FWHM too large ({fwhm_values[ifile]:.1f} > {fthresh:.1f}))"
                    )
                    continue

                print("resampling frame", ifile + 1)
                nframes_used += 1

                # find offset from previous frame
                cumulative_offset_x, cumulative_offset_y = offsets[ifile]

                # find output shape to resample each window onto (binned)
                # full frame array
                output_shape = (ccd.nytot // ccd.head.ybin, ccd.nxtot // ccd.head.xbin)

                # add this CCD to the list of arrays
                for wnam, wind in ccd.items():
                    # make WCS to reproject data onto full frame
                    # (binned) array
                    pixel_wcs = copy.deepcopy(orig_wcs)
                    crval1, crval2 = pixel_wcs.wcs.crpix
                    window_offset_x = (wind.llx - 1) / wind.xbin
                    window_offset_y = (wind.lly - 1) / wind.ybin
                    pixel_wcs.wcs.crpix = (
                        crval1 + cumulative_offset_x - window_offset_x,
                        crval2 + cumulative_offset_y - window_offset_y,
                    )

                    # carry out the re-projection
                    if reprmethod == "interp":
                        reprojected_data, _ = reproject_interp(
                            (wind.data, pixel_wcs),
                            orig_wcs,
                            output_shape,
                            order=reprorder,
                        )
                    elif reprmethod == "exact":
                        reprojected_data, _ = reproject_exact(
                            (wind.data, pixel_wcs),
                            orig_wcs,
                            output_shape,
                        )
                    # OK - we are using adaptive then
                    elif reprkernel == "Hann":
                        reprojected_data, _ = reproject_adaptive(
                            (wind.data, pixel_wcs),
                            orig_wcs,
                            output_shape,
                            conserve_flux=consflux,
                            kernel="Hann",
                        )
                    else:
                        reprojected_data, _ = reproject_adaptive(
                            (wind.data, pixel_wcs),
                            orig_wcs,
                            output_shape,
                            conserve_flux=consflux,
                            kernel_width=kwidth,
                            sample_region_width=regwidth,
                            kernel="Gaussian",
                        )
                    arrs.append(reprojected_data)

            # average over the stack
            print(f"combining {nframes_used} frames for CCD {cnam}")
            header_string += f",CCD{cnam}({nframes_used:d})"
            arr3d = np.stack(arrs)

            # set exposure time in header
            output_mccd[cnam].head["EXPTIME"] *= nframes_used

            if method == "m":
                stack = medianfunc(arr3d, axis=0)
            elif method == "c" and sigma > 0:
                # clipped mean
                mask = sigma_clip(
                    arr3d,
                    sigma_lower=sigma,
                    sigma_upper=sigma,
                    axis=0,
                    copy=False,
                    maxiters=maxiters,
                    cenfunc="mean",
                    stdfunc="std",
                    masked=True,
                )
                # fill masked with nans
                arr3d[mask.mask] = np.nan
                stack = meanfunc(arr3d, axis=0)
            else:
                # simple mean
                stack = meanfunc(arr3d, axis=0)

            # resample the FF image back into the individual windows
            # of the CCD.
            for wnam, wind in output_mccd[cnam].items():
                xstart = (wind.llx - 1) // wind.xbin
                xend = xstart + wind.nx
                ystart = (wind.lly - 1) // wind.ybin
                yend = ystart + wind.ny
                crop = stack[ystart:yend, xstart:xend]
                output_mccd[cnam][wnam].data = crop

        # TODO: setting reproject options
        if method == "m":
            output_mccd.head.add_history("Median stack: " + header_string)
        else:
            output_mccd.head.add_history(
                f"Clipped mean stack ({sigma:.1f} sigma): " + header_string
            )
        output_mccd.write(outfile, overwrite=overwrite)
        print(f"Written {outfile}")
