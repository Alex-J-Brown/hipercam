"""Command line script to generate meta data"""

import sys
import os
import time
import re

import numpy as np

import hipercam as hcam
from hipercam import cline, utils, spooler
from hipercam.cline import Cline

__all__ = [
    "hmeta",
]

#############################
#
# hmeta -- generate meta data
#
#############################


def hmeta(args=None):
    """hmeta

    This command is to be run in the "raw_data" directory containing
    night-by-night directories of data for |hipercam|, ULTRACAM or
    ULTRASPEC. It attempts to generate meta data on any run data it
    can find and write this to a file in a sub-directory called
    meta. These data can be picked up by logging scripts. The sort of
    data it produces are means, medians etc of the frames (or some of
    the frames -- up to a maximum of 100) of each run. The program
    only considers genuine frames, i.e. it copes with the nblue and nskip
    options of ULTRACAM and |hipercam|.

    """

    cwd = os.getcwd()
    if os.path.basename(cwd) != "raw_data":
        print("** hmeta must be run in a directory called 'raw_data'")
        print("hmeta aborted", file=sys.stderr)
        return

    if cwd.find("ultracam") > -1:
        instrument = "ULTRACAM"
        itype = 'U'
        source = 'ul'
    elif cwd.find("ultraspec") > -1:
        instrument = "ULTRASPEC"
        itype = 'U'
        source = 'ul'
    elif cwd.find("hipercam") > -1:
        instrument = "HiPERCAM"
        itype = 'H'
        source = 'hl'
    else:
        print("** hmeta: cannot find either ultracam, ultraspec or hipercam in path")
        print("hmeta aborted", file=sys.stderr)
        return

    linstrument = instrument.lower()

    # Now the actual work.  Next are regular expressions to match run
    # directories, nights, and run files
    nre = re.compile("^\d\d\d\d-\d\d-\d\d$")
    ure = re.compile("^run\d\d\d\.xml$")
    hre = re.compile("^run\d\d\d\d\.fits$")

    # Get list of night directories
    nnames = [
        nname
        for nname in os.listdir(".")
        if nre.match(nname)
        and os.path.isdir(nname)
    ]
    nnames.sort()

    if len(nnames) == 0:
        print("no night directories found", file=sys.stderr)
        print("hmeta aborted", file=sys.stderr)
        return


    for nname in nnames:

        print(f"  night {nname}")

        # load all the run names
        if itype == 'U':
            runs = [run[:-4] for run in os.listdir(nname) if ure.match(run) and
                    os.path.exists(os.path.join(nname,run[:-4]+'.dat'))]
        else:
            runs = [run[:-5] for run in os.listdir(nname) if hre.match(run)]
        runs.sort()

        if len(runs) == 0:
            print(f' No runs with data found in {nname}; skipping')
            continue

        # create directory for any meta info such as the times
        meta = os.path.join(nname, 'meta')
        os.makedirs(meta, exist_ok=True)

        # name of stats file
        stats = os.path.join(meta, 'statistics')
        if os.path.exists(stats):
            # if file already present, don't attempt to re-compute
            continue

        with open(stats, "w") as fstats:
            fstats.write('# This file was generated by hmeta\n')
            for run in runs:
                dfile = os.path.join(nname, run)

                if itype == 'U':
                    rdat = hcam.ucam.Rdata(dfile)
                else:
                    rdat = hcam.hcam.Rdata(dfile, 1, False, False)

                # For speed, analyse a maximum of approximately 100
                # images of each CCD from any given run. Have to take
                # into account the skips / nblue parameters.
                ntotal = rdat.ntotal()

                nframes = []
                ncframes = {}
                if instrument == 'ULTRASPEC':
                    # just the one CCD here
                    nstep = ntotal // min(ntotal, 100)
                    ncframes['1'] = list(range(1,ntotal+1,nstep))
                    nframes = ncframes['1']

                elif instrument == 'ULTRACAM':
                    # CCD 1, 2 read out each time, but 3 can be skipped
                    nstep = ntotal // min(ntotal, 100)
                    ncframes['1'] = list(range(1,ntotal+1,nstep))
                    ncframes['2'] = ncframes['1']

                    nb = rdat.nblue
                    nbstep = max(1, ntotal // min(ntotal, 100*(nb+1)))
                    ncframes['3'] = list(range(nb,ntotal+1,nstep))
                    nframes = sorted(set(ncframes['1']+ncframes['3']))

                else:
                    raise NotImplementedError('HiPERCAM case not done yet')

                # define arrays for holding the stats
                means = {}
                for cnam, ncframe in ncframes.items():
                    means[cnam] = np.empty_like(ncframe,dtype=np.float)

                # now access the data and calculate the stats
                for n, nf in enumerate(nframes):
                    mccd = rdat(nf)
                    for cnam in ncframes:
                        ncframe = ncframes[cnam]
                        if nf in ncframe:
                            ccd = mccd[cnam]
                            means[cnam][n] = ccd.mean()
                            
                # All extracted from the run; take and store medians of
                # the extracted stats
                for cnam, mvals in means.items():
                    print(run, cnam, np.median(mvals))
        break
