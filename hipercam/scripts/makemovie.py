import sys
import os
import time

import numpy as np

import matplotlib.pylab as plt
from matplotlib.gridspec import GridSpec

from astropy.time import Time

import hipercam as hcam
from hipercam import cline, utils, spooler, defect
from hipercam.cline import Cline
from hipercam import mpl, hlog

import requests
import socket

# colour for setup windows. works for me at least
# but may need input from Stu
COL_SETUP = (0.8, 0., 0.)

__all__ = [
    "makemovie",
]

##########################################
#
# makemovie -- generates stills for movies
#
##########################################


def makemovie(args=None):
    """``makemovie [source] (run first last | flist) trim ([ncol nrow])
    (ccd (nx)) bias flat defect log (targ comp ymin ymax yscales
    yoffset location fraction lpad) cmap width height dstore ndigit fext msub iset
    (ilo ihi | plo phi) xlo xhi ylo yhi [dpi]``

    ``makemovie`` is for generating stills to combine into a movie for
    presentations. It can optionally also read a log file from the run
    to display an evolving light curve. There are lots of fiddly
    parameters mostly to do with the plot positioning, so try it out
    on a small number of frames first before going mad.

    Parameters:

        source : str [hidden]
           Data source, five options:

             |  'hs' : HiPERCAM server
             |  'hl' : local HiPERCAM FITS file
             |  'us' : ULTRACAM server
             |  'ul' : local ULTRACAM .xml/.dat files
             |  'hf' : list of HiPERCAM hcm FITS-format files

           'hf' is used to look at sets of frames generated by 'grab'
           or converted from foreign data formats. The standard
           start-off default for ``source`` can be set using the
           environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
           :code:`export HIPERCAM_DEFAULT_SOURCE="us"` would ensure it
           always started with the ULTRACAM server by default. If
           unspecified, it defaults to 'hl'.

        run : str [if source ends 's' or 'l']
           run number to access, e.g. 'run034'

        flist : str [if source ends 'f']
           name of file list

        first : int [if source ends 's' or 'l']
           exposure number to start from. 1 = first frame.

        last : int [if source ends 's' or 'l']
           last exposure

        trim : bool [if source starts with 'u']
           True to trim columns and/or rows off the edges of windows nearest
           the readout which can sometimes contain bad data.

        ncol : int [if trim, hidden]
           Number of columns to remove (on left of left-hand window, and right
           of right-hand windows)

        nrow : int [if trim, hidden]
           Number of rows to remove (bottom of windows)

        ccd : str
           CCD(s) to plot, '0' for all, '1 3' to plot '1' and '3' only, etc.

        nx : int [if more than 1 CCD]
           number of panels across to display for the image display.

        bias : str
           Name of bias frame to subtract, 'none' to ignore.

        flat : str
           Name of flat field to divide by, 'none' to ignore. Should normally
           only be used in conjunction with a bias, although it does allow you
           to specify a flat even if you haven't specified a bias.

        defect : str
           Name of defect file, 'none' to ignore.

        log : str
           Name of reduce log file for light curve plot, 'none' to ignore

        targ : str [if log defined]
           Target aperture

        comp : str [if log defined]
           Comparison aperture

        ymin : float [if log defined]
           Minimum Y value for light curve plot

        ymax : float [if log defined]
           Maximum Y value for light curve plot

        ynorm : list(float) [if log defined]
           Normalisation factors, one per CCD for light curve plot

        yoffset : list(float) [if log defined]
           Offsets, one per CCD for light curve plot

        location : str [if log defined]
           Offsets, one per CCD for light curve plot

        fraction : float [if log defined]
           Fraction of figure to occupy, by height if location is South,
           by width if it is East

        lpad : tuple(float) [if log defined]
           padding on left, bottom, right and top of light curve plot as fraction
           of allocated width and height

        cmap : str
           The matplotlib colour map to use. "Greys" gives the usual greyscale.
           "none" will give whatever the current default is. Many other choices:
           "viridis", "jet", "hot", "Oranges", etc. Enter an invalid one and
           the program will fail but return a huge list of possibles in the
           process.

        width : float
           plot width in inches.

        height : float
           plot height in inches.

        dstore : str
           root directory for plot files. Will get names like dstore/run003_001.png.

        ndigit : int
           number of digits in frame counter, i.e. the '001' of the previous section.

        fext : str
           file extension 'png', 'jpeg' for images generated

        msub : bool
           subtract the median from each window before scaling for the
           image display or not. This happens after any bias subtraction.

        iset : str [single character]
           determines how the intensities are determined. There are three
           options: 'a' for automatic simply scales from the minimum to the
           maximum value found on a per CCD basis. 'd' for direct just takes
           two numbers from the user. 'p' for percentile dtermines levels
           based upon percentiles determined from the entire CCD on a per CCD
           basis.

        ilo : list(float) [if iset='d']
           lower intensity level, one per image

        ihi : list(float) [if iset='d']
           upper intensity level, one per image

        plo : float [if iset='p']
           lower percentile level

        phi : float [if iset='p']
           upper percentile level

        xlo : float
           left-hand X-limit for plot, initially at least since it is
           possible to re-size. For iset='p' these limits also set the
           region of the frame over which the percentil will be
           calculated. You will usually want yhi-ylo ~ xhi-xlo in
           magnitude because the aspect ratio is preserved.

        xhi : float
           right-hand X-limit for plot (can be < xlo to invert the display)

        ylo : float
           lower Y-limit for plot

        yhi : float
           upper Y-limit for plot (can be < ylo)

        dpi : int [hidden]
           dots per inch of output. Default 72. Allows control over font size versus image size,
           in combination with width and height.
    """

    command, args = utils.script_args(args)

    # get the inputs
    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:

        # register parameters
        cl.register("source", Cline.GLOBAL, Cline.HIDE)
        cl.register("run", Cline.GLOBAL, Cline.PROMPT)
        cl.register("first", Cline.LOCAL, Cline.PROMPT)
        cl.register("last", Cline.LOCAL, Cline.PROMPT)
        cl.register("trim", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ncol", Cline.GLOBAL, Cline.HIDE)
        cl.register("nrow", Cline.GLOBAL, Cline.HIDE)
        cl.register("flist", Cline.LOCAL, Cline.PROMPT)
        cl.register("ccd", Cline.LOCAL, Cline.PROMPT)
        cl.register("nx", Cline.LOCAL, Cline.PROMPT)
        cl.register("bias", Cline.GLOBAL, Cline.PROMPT)
        cl.register("flat", Cline.GLOBAL, Cline.PROMPT)
        cl.register("defect", Cline.GLOBAL, Cline.PROMPT)
        cl.register("log", Cline.LOCAL, Cline.PROMPT)
        cl.register("targ", Cline.LOCAL, Cline.PROMPT)
        cl.register("comp", Cline.LOCAL, Cline.PROMPT)
        cl.register("ymin", Cline.LOCAL, Cline.PROMPT)
        cl.register("ymax", Cline.LOCAL, Cline.PROMPT)
        cl.register("ynorm", Cline.LOCAL, Cline.PROMPT)
        cl.register("yoffset", Cline.LOCAL, Cline.PROMPT)
        cl.register("location", Cline.LOCAL, Cline.PROMPT)
        cl.register("fraction", Cline.LOCAL, Cline.PROMPT)
        cl.register("lpad", Cline.LOCAL, Cline.PROMPT)
        cl.register("cmap", Cline.LOCAL, Cline.PROMPT)
        cl.register("width", Cline.LOCAL, Cline.PROMPT)
        cl.register("height", Cline.LOCAL, Cline.PROMPT)
        cl.register("dstore", Cline.LOCAL, Cline.PROMPT)
        cl.register("ndigit", Cline.LOCAL, Cline.PROMPT)
        cl.register("fext", Cline.LOCAL, Cline.PROMPT)
        cl.register("msub", Cline.GLOBAL, Cline.PROMPT)
        cl.register("iset", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ilo", Cline.LOCAL, Cline.PROMPT)
        cl.register("ihi", Cline.LOCAL, Cline.PROMPT)
        cl.register("plo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("phi", Cline.LOCAL, Cline.PROMPT)
        cl.register("xlo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("xhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ylo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("yhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("dpi", Cline.LOCAL, Cline.HIDE)

        # get inputs
        default_source = os.environ.get('HIPERCAM_DEFAULT_SOURCE','hl')
        source = cl.get_value(
            "source",
            "data source [hs, hl, us, ul, hf]",
            default_source,
            lvals=("hs", "hl", "us", "ul", "hf"),
        )

        # set some flags
        server_or_local = source.endswith("s") or source.endswith("l")

        if server_or_local:
            resource = cl.get_value("run", "run name", "run005")
            first = cl.get_value("first", "first frame to plot", 1)
            last = cl.get_value("last", "last frame to plot [0 to go to the end]", max(1,first), first)
        else:
            resource = cl.get_value(
                "flist", "file list", cline.Fname("files.lis", hcam.LIST)
            )
            first = 1

        trim = cl.get_value("trim", "do you want to trim edges of windows?", True)
        if trim:
            ncol = cl.get_value("ncol", "number of columns to trim from windows", 0)
            nrow = cl.get_value("nrow", "number of rows to trim from windows", 0)
        else:
            ncol, nrow = None, None

        # define the panel grid. first get the labels and maximum dimensions
        ccdinf = spooler.get_ccd_pars(source, resource)

        nxdef = cl.get_default("nx", 3)

        if len(ccdinf) > 1:
            ccd = cl.get_value("ccd", "CCD(s) to plot [0 for all]", "0")
            if ccd == "0":
                ccds = list(ccdinf.keys())
            else:
                ccds = ccd.split()
                check = set(ccdinf.keys())
                if not set(ccds) <= check:
                    raise hcam.HipercamError("At least one invalid CCD label supplied")

            if len(ccds) > 1:
                nxdef = min(len(ccds), nxdef)
                cl.set_default("nx", nxdef)
                nx = cl.get_value("nx", "number of panels in X", 3, 1)
            else:
                nx = 1
        else:
            nx = 1
            ccds = list(ccdinf.keys())

        # bias frame (if any)
        bias = cl.get_value(
            "bias",
            "bias frame ['none' to ignore]",
            cline.Fname("bias", hcam.HCAM),
            ignore="none",
        )
        if bias is not None:
            # read the bias frame
            bias = hcam.MCCD.read(bias)
            fprompt = "flat frame ['none' to ignore]"
        else:
            fprompt = "flat frame ['none' is normal choice with no bias]"

        # flat (if any)
        flat = cl.get_value(
            "flat", fprompt, cline.Fname("flat", hcam.HCAM), ignore="none"
        )
        if flat is not None:
            # read the flat frame
            flat = hcam.MCCD.read(flat)

        # defect file (if any)
        dfct = cl.get_value(
            "defect",
            "defect file ['none' to ignore]",
            cline.Fname("defect", hcam.DFCT),
            ignore="none",
        )
        if dfct is not None:
            # read the defect frame
            dfct = defect.MccdDefect.read(dfct)

        # reduce log file (if any)
        rlog = cl.get_value(
            "log",
            "reduce log file ['none' to ignore]",
            cline.Fname("reduce", hcam.LOG),
            ignore="none",
        )

        if rlog is not None:
            # Read reduce file
            hlg = hlog.Hlog.rascii(rlog)
            targ = cl.get_value("targ", "target aperture", "1")
            comp = cl.get_value("comp", "comparison aperture", "2")
            fmin = cl.get_value("ymin", "minimum Y value for light curve plot", 0.)
            fmax = cl.get_value("ymax", "maxmum Y value for light curve plot", 1.)

            # need to check that the default has the right number of
            # items, if not overr-ride it
            ynorm = cl.get_default("ynorm")
            if ynorm is not None:
                if len(ynorm) > len(ccds):
                    cl.set_default("ynorm", ynorm[:len(ccds)])
                elif len(ynorm) < len(ccds):
                    cl.set_default("ynorm", ynorm + (len(ccds)-len(ynorm))*[1.])

            ynorm = cl.get_value(
                "ynorm",
                "normalisation factors for light curves (one per CCD)",
                len(ccds)*[1.]
            )

            yoffset = cl.get_default("yoffset")
            if yoffset is not None:
                if len(yoffset) > len(ccds):
                    cl.set_default("yoffset", yoffset[:len(ccds)])
                elif len(yoffset) < len(ccds):
                    cl.set_default("yoffset", yoffset + (len(ccds)-len(yoffset))*[0.])

            yoffset = cl.get_value(
                "yoffset",
                "vertical offsets for light curves (one per CCD)",
                len(ccds)*[0.]
            )

            location =  cl.get_value(
                "location",
                "position of light curve plot relative to images", "s",
                lvals=['s','e','S','E']
            )
            if location.lower() == 's':
                fraction =  cl.get_value(
                    "fraction",
                    "fraction of figure in terms of height occupied by light curve",
                    0.5
                )
            elif location.lower() == 'e':
                fraction = cl.get_value(
                    "fraction",
                    "fraction of figure in terms of width occupied by light curve",
                    0.67
                )
            lpad = cl.get_value(
                "lpad",
                "padding (left,bottom,right,top) around light curve plot",
                (0.05,0.05,0.02,0.02)
            )

            # trim down to the specified frames
            lcs = []
            T0, tmax = None, None
            for cnam, yn, yo in zip(ccds, ynorm, yoffset):
                nframes = hlg[cnam]['nframe']
                keep = (nframes >= first) & (nframes <= last)
                hlg[cnam] = hlg[cnam][keep]
                lc = (hlg.tseries(cnam,targ) / hlg.tseries(cnam,comp)) / yn + yo
                if T0 is None:
                    T0 = lc.t.min()
                lc.ttrans(lambda t : 1440*(t-T0))
                if tmax is None:
                    tmax = lc.t.max()
                else:
                    tmax = max(tmax, lc.t.max())
                lcs.append(
                    (nframes[keep], lc)
                )

        # Some settings for the image plots
        cmap = cl.get_value("cmap", "colour map to use ['none' for mpl default]", "Greys")
        cmap = None if cmap == "none" else cmap

        width = cl.get_value(
            "width", "plot width [inches]", 10., 0.5
        )

        height = cl.get_value(
            "height", "plot height [inches]", 10., 0.5
        )

        dstore = cl.get_value("dstore", "directory for images", "tmp")
        if not os.path.isdir(dstore):
            raise hcam.HipercamError(f"'{dstore}' is not a directory")

        ndigit = cl.get_value("ndigit", "number of digits for appended frame counter", 4, 1)
        fext = cl.get_value(
            "fext", "file extension for images", "png",
            lvals=["png","jpg"]
        )

        # define the display intensities
        msub = cl.get_value("msub", "subtract median from each window?", True)

        iset = cl.get_value(
            "iset",
            "set intensity a(utomatically)," " d(irectly) or with p(ercentiles)?",
            "a",
            lvals=["a", "d", "p"],
        )
        iset = iset.lower()

        plo, phi = 5, 95
        ilos, ihis = len(ccds)*[0], len(ccds)*[1000]
        if iset == "d":
            # fiddle with the defaults
            ilo = cl.get_default("ilo")
            if ilo is not None:
                if len(ilo) > len(ccds):
                    cl.set_default("ilo", ilo[:len(ccds)])
                elif len(ilo) < len(ccds):
                    cl.set_default("ilo", ilo + (len(ccds)-len(ilo))*[0.])

            ihi = cl.get_default("ihi")
            if ihi is not None:
                if len(ihi) > len(ccds):
                    cl.set_default("ihi", ihi[:len(ccds)])
                elif len(ihi) < len(ccds):
                    cl.set_default("ihi", ihi + (len(ccds)-len(ihi))[1000.])

            ilos = cl.get_value("ilo", "lower intensity limit", len(ccds)*[0.])
            ihis = cl.get_value("ihi", "upper intensity limit", len(ccds)*[1000.])

        elif iset == "p":
            plo = cl.get_value(
                "plo", "lower intensity limit percentile", 5.0, 0.0, 100.0
            )
            phi = cl.get_value(
                "phi", "upper intensity limit percentile", 95.0, 0.0, 100.0
            )

        # region to plot
        for i, cnam in enumerate(ccds):
            nxtot, nytot, nxpad, nypad = ccdinf[cnam]
            if i == 0:
                xmin, xmax = float(-nxpad), float(nxtot + nxpad + 1)
                ymin, ymax = float(-nypad), float(nytot + nypad + 1)
            else:
                xmin = min(xmin, float(-nxpad))
                xmax = max(xmax, float(nxtot + nxpad + 1))
                ymin = min(ymin, float(-nypad))
                ymax = max(ymax, float(nytot + nypad + 1))

        xlo = cl.get_value("xlo", "left-hand X value", xmin, xmin, xmax)
        xhi = cl.get_value("xhi", "right-hand X value", xmax, xmin, xmax)
        ylo = cl.get_value("ylo", "lower Y value", ymin, ymin, ymax)
        yhi = cl.get_value("yhi", "upper Y value", ymax, ymin, ymax)
        dpi = cl.get_value("dpi", "dots per inch", 72)

    ###############################################################################

    # Phew. We finally have all the inputs and now can now display stuff.

    # track which CCDs have been plotted at least once for the profile fits
    nccd = len(ccds)
    plotted = np.array(nccd*[False])
    current_ccds = nccd*[None]
    ny = nccd // nx if nccd % nx == 0 else nccd // nx + 1

    first_image = True

    # Now go through data
    with spooler.data_source(source, resource, first, full=False) as spool:

        for nframe, mccd in enumerate(spool):

            # Trim the frames: ULTRACAM windowed data has bad columns
            # and rows on the sides of windows closest to the readout
            # which can badly affect reduction. This option strips
            # them.
            if trim:
                hcam.ccd.trim_ultracam(mccd, ncol, nrow)

            # indicate progress
            tstamp = Time(mccd.head["TIMSTAMP"], format="isot", precision=3)
            print(f'{mccd.head.get("NFRAME",nframe+1)}, utc= {tstamp.iso}')

            if nframe == 0:
                # get the bias and flat into shape first time through

                if bias is not None:
                    # crop the bias on the first frame only
                    bias = bias.crop(mccd)

                if flat is not None:
                    # crop the flat on the first frame only
                    flat = flat.crop(mccd)

            # wind through the CCDs to display, accumulating stuff
            # to send to the plot manager
            message = ""

            skipped = True
            for nc, cnam in enumerate(ccds):
                ccd = mccd[cnam]

                if ccd.is_data():
                    # "is_data" indicates genuine data as opposed to junk
                    # that results from nskip > 0.
                    plotted[nc] = True

                    # subtract the bias
                    if bias is not None:
                        ccd -= bias[cnam]

                    # divide out the flat
                    if flat is not None:
                        ccd /= flat[cnam]

                    if msub:
                        # subtract median from each window
                        for wind in ccd.values():
                            wind -= wind.median()

                    # keep list of current CCDs
                    current_ccds[nc] = ccd

            # at this point current_ccds contains the current set of CCDs to plot

            if plotted.all():

                # Finally have at least one proper exposure of all
                # CCDs and can make plots every time with skipped
                # frames staying unchanged Set up the plot. ny by nx
                # rows x columns of images + 1 for optional light
                # curve which is either South or East of images

                fig = plt.figure(figsize=(width,height))

                if rlog is not None:
                    # plot light curve

                    # first the location
                    if location.lower() == 's':
                        # light curve "South" of the images
                        rect = [lpad[0],fraction*lpad[1],1-lpad[0]-lpad[2],fraction*(1-lpad[1]-lpad[3])]
                        gs = GridSpec(ny, nx, figure=fig, bottom=fraction)
                    elif location.lower() == 'e':
                        # light curve "East" of the images
                        rect = [1-fraction+fraction*lpad[0],lpad[1],fraction*(1-lpad[0]-lpad[2]),1-lpad[1]-lpad[3]]
                        gs = GridSpec(ny, nx, right=1-fraction)

                    # light curve axes
                    ax = fig.add_axes(rect)
                    ax.set_xlim(0,tmax)
                    ax.set_ylim(fmin,fmax)
                    ax.set_xlabel(f'Time [mins, since MJD = {T0}]')
                    ax.set_ylabel(f'Target / Comparison')
                    ax.tick_params(axis="x", direction="in")
                    ax.tick_params(axis="y", direction="in", rotation=90)
                    ax.tick_params(bottom=True, top=True, left=True, right=True)
                    for cnam, (nframes, lc) in zip(ccds, lcs):
                        plot = (nframes >= first) & (nframes <= first+nframe)
                        lct = lc[plot]
                        lct.mplot(ax, color=None, label=f'CCD {cnam}')
                    ax.legend(loc='upper right')
                else:
                    # images only
                    gs = GridSpec(ny, nx, figure=fig)

                # plot images
                for n, (cnam, ccd, ilo, ihi)  in enumerate(zip(ccds, current_ccds, ilos, ihis)):
                    ax = fig.add_subplot(gs[n // nx, n % nx])
                    mpl.pCcd(ax, ccd, iset, plo, phi, ilo, ihi, f'CCD {cnam}', xlo, xhi, ylo, yhi, cmap)
                    ax.set_xlim(xlo,xhi)
                    ax.set_ylim(ylo,yhi)
                    ax.tick_params(axis="x", direction="in")
                    ax.tick_params(axis="y", direction="in", rotation=90)
                    ax.tick_params(bottom=True, top=True, left=True, right=True)

                oname = os.path.join(dstore, f'{os.path.basename(resource)}_{first+nframe:0{ndigit}d}.{fext}')
                plt.savefig(oname,dpi=dpi)
                plt.close()
                print(f'   written figure to {oname}')

            if nframe + first == last:
                break
