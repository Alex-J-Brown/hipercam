import sys
import os

import numpy as np

import hipercam as hcam
from hipercam import cline, utils
from hipercam.cline import Cline

__all__ = [
    "averun",
]

#################################
#
# averun -- median average images
#
#################################


def averun(args=None):
    """``averun [source] (run first last twait tmax | flist) trim ([ncol
    nrow]) bias dark flat [method sigma adjust clobber] output``

    Averages images from a run using median combination, skipping the junk
    frames that result from NSKIP / NBLUE options in HiPERCAM and ULTRACAM
    data. `averun` is meant to be a simple tool to create median frames
    suitable prior to aperture selection with `setaper`. See `combine` if you
    want more fine-grained control over frame averaging. (`averun` uses a
    combination of `grab` [if needed] and `combine`).

    Parameters:

        source : str [hidden]
           Data source, five options:

              | 'hs' : HiPERCAM server
              | 'hl' : local HiPERCAM FITS file
              | 'us' : ULTRACAM server
              | 'ul' : local ULTRACAM .xml/.dat files
              | 'hf' : list of HiPERCAM hcm FITS-format files

           'hf' is used to look at sets of frames generated by 'grab'
           or converted from foreign data formats. The standard
           start-off default for ``source`` can be set using the
           environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
           :code:`export HIPERCAM_DEFAULT_SOURCE="us"` would ensure it
           always started with the ULTRACAM server by default. If
           unspecified, it defaults to 'hl'.

        run : str [if source ends 's' or 'l']
           run number to access, e.g. 'run034'

        flist : str [if source ends 'f']
           name of file list

        first : int [if source ends 's' or 'l']
           exposure number to start from. 1 = first frame ('0' is
           not supported).

        last : int [if source ends 's' or 'l']
           last exposure number must be >= first.

        twait : float [if source ends 's' or 'l'; hidden]
           time to wait between attempts to find a new exposure, seconds.

        tmax : float [if source ends 's' or 'l'; hidden]
           maximum time to wait between attempts to find a new exposure,
           seconds.

        trim : bool
           True to trim columns and/or rows off the edges of windows nearest
           the readout. Useful for ULTRACAM particularly.

        ncol : int [if trim, hidden]
           Number of columns to remove (on left of left-hand window, and right
           of right-hand windows)

        nrow : int [if trim, hidden]
           Number of rows to remove (bottom of windows)

        bias : str
           Name of bias frame to subtract, 'none' to ignore.

        dark : str
           Name of dark frame to subtract, 'none' to ignore.

        flat : str
           Name of flat field to divide by, 'none' to ignore.

        method : str [hidden, defaults to 'm']
           'm' for median, 'c' for clipped mean. See below for pros and cons.

        sigma : float [hidden; if method == 'c']
           With clipped mean combination, pixels that deviate by more than
           sigma RMS from the mean are kicked out. This is carried out in an
           iterative manner. sigma <= 0 implies no rejection, just a straight
           average. sigma=3 is typical.

        adjust : str [hidden; defaults to 'i']
           adjustments to make: 'i' = ignore; 'n' = normalise the mean of all
           frames to match the first; 'b' = add offsets so that the mean of
           all frames is the same as the first.  Option 'n' is useful for
           twilight flats; 'b' for combining biases.

        clobber : bool [hidden]
           clobber any pre-existing output files

        output : str
           output file. Set by default to match the last part of "run" (but it will have a different
           extension so they won't clash)

    """

    command, args = utils.script_args(args)

    # get the inputs
    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:

        # register parameters
        cl.register("source", Cline.GLOBAL, Cline.HIDE)
        cl.register("run", Cline.GLOBAL, Cline.PROMPT)
        cl.register("first", Cline.LOCAL, Cline.PROMPT)
        cl.register("last", Cline.LOCAL, Cline.PROMPT)
        cl.register("twait", Cline.LOCAL, Cline.HIDE)
        cl.register("tmax", Cline.LOCAL, Cline.HIDE)
        cl.register("trim", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ncol", Cline.GLOBAL, Cline.HIDE)
        cl.register("nrow", Cline.GLOBAL, Cline.HIDE)
        cl.register("flist", Cline.LOCAL, Cline.PROMPT)
        cl.register("bias", Cline.LOCAL, Cline.PROMPT)
        cl.register("dark", Cline.LOCAL, Cline.PROMPT)
        cl.register("flat", Cline.LOCAL, Cline.PROMPT)
        cl.register("method", Cline.LOCAL, Cline.HIDE)
        cl.register("sigma", Cline.LOCAL, Cline.HIDE)
        cl.register("adjust", Cline.LOCAL, Cline.HIDE)
        cl.register("clobber", Cline.LOCAL, Cline.HIDE)
        cl.register("output", Cline.LOCAL, Cline.PROMPT)

        # get inputs
        default_source = os.environ.get('HIPERCAM_DEFAULT_SOURCE','hl')
        source = cl.get_value(
            "source",
            "data source [hs, hl, us, ul, hf]",
            default_source,
            lvals=("hs", "hl", "us", "ul", "hf"),
        )

        # set a flag
        server_or_local = source.endswith("s") or source.endswith("l")

        if server_or_local:
            run = cl.get_value("run", "run name", "run005")
            root = os.path.basename(run)
            cl.set_default('output', cline.Fname(root, hcam.HCAM))

            first = cl.get_value("first", "first frame to average", 1, 1)
            last = cl.get_value("last", "last frame to average", first, first)

            twait = cl.get_value(
                "twait", "time to wait for a new frame [secs]", 1.0, 0.0
            )
            tmax = cl.get_value(
                "tmax", "maximum time to wait for a new frame [secs]", 10.0, 0.0
            )

        else:
            flist = cl.get_value(
                "flist", "file list", cline.Fname("files.lis", hcam.LIST)
            )
            first = 1

        trim = cl.get_value("trim", "do you want to trim edges of windows?", True)
        if trim:
            ncol = cl.get_value("ncol", "number of columns to trim from windows", 0)
            nrow = cl.get_value("nrow", "number of rows to trim from windows", 0)

        # bias frame (if any)
        bias = cl.get_value(
            "bias",
            "bias frame ['none' to ignore]",
            cline.Fname("bias", hcam.HCAM),
            ignore="none",
        )

        # dark frame (if any)
        dark = cl.get_value(
            "dark",
            "dark frame ['none' to ignore]",
            cline.Fname("dark", hcam.HCAM),
            ignore="none",
        )

        # flat field frame (if any)
        flat = cl.get_value(
            "flat",
            "flat field frame ['none' to ignore]",
            cline.Fname("flat", hcam.HCAM),
            ignore="none",
        )

        cl.set_default("method", "m")
        method = cl.get_value(
            "method", "c(lipped mean), m(edian)", "c", lvals=("c", "m")
        )

        if method == "c":
            sigma = cl.get_value("sigma", "number of RMS deviations to clip", 3.0)

        cl.set_default("adjust", "i")
        adjust = cl.get_value(
            "adjust", "i(gnore), n(ormalise) b(ias offsets)", "i", lvals=("i", "n", "b")
        )

        clobber = cl.get_value(
            "clobber", "clobber any pre-existing files on output", False
        )

        output = cl.get_value(
            "output",
            "output average",
            cline.Fname(
                "hcam", hcam.HCAM, cline.Fname.NEW if clobber else cline.Fname.NOCLOBBER
            ),
        )

    # inputs done with. Now do the work with 'grab' and 'combine'

    if server_or_local:
        print("\nCalling 'grab' ...")

        if trim:
            args = [
                None,
                "prompt",
                source,
                run,
                "yes",
                str(first),
                str(last),
                "yes",
                str(ncol),
                str(nrow),
                str(twait),
                str(tmax),
                "none",
                "f32",
            ]
        else:
            args = [
                None,
                "prompt",
                source,
                run,
                "yes",
                str(first),
                str(last),
                "no",
                str(twait),
                str(tmax),
                "none",
                "f32",
            ]
        print("arg =", args)
        flist = hcam.scripts.grab(args)

    try:
        print("\nCalling 'combine' ...")
        if method == "m":
            args = [
                None,
                "prompt",
                flist,
                "none" if bias is None else bias,
                "none" if dark is None else dark,
                "none" if flat is None else flat,
                method,
                adjust,
                "usemean=yes",
                "plot=no",
                "yes" if clobber else "no",
                output,
            ]
        else:
            args = [
                None,
                "prompt",
                flist,
                "none" if bias is None else bias,
                "none" if dark is None else dark,
                "none" if flat is None else flat,
                method,
                str(sigma),
                adjust,
                "usemean=yes",
                "plot=no",
                "yes" if clobber else "no",
                output,
            ]
        hcam.scripts.combine(args)

        # remove temporary files
        with open(flist) as fin:
            for fname in fin:
                fname = fname.strip()
                os.remove(fname)
        os.remove(flist)
        print("\ntemporary files have been deleted")
        print("averun finished")

    except KeyboardInterrupt:
        # this to ensure we delete the temporary files
        with open(flist) as fin:
            for fname in fin:
                fname = fname.strip()
                os.remove(fname)
        os.remove(flist)
        print("\ntemporary files have been deleted")
        print("averun aborted")
