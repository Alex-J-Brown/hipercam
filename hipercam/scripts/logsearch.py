import sys
import re
import sqlite3
import os
import keyring
import getpass
import subprocess

import numpy as np
import pandas as pd

import hipercam as hcam
from hipercam import cline, utils
from hipercam.cline import Cline
from hipercam.utils import target_lookup

__all__ = [
    "logsearch",
]

#######################################################################
#
# logsearch -- carries out a search for objects in data logs
#
#######################################################################

def logsearch(args=None):
    description = \
    """``logsearch target (dmax) regex (nocase) tmin output``

    Searches for targets in the |hiper| and |ucam| logs. It can carry
    out a coordinate lookup given a name and/or carry out a regular
    expression search. It uses the sqlite3 databases generated by
    |hlogger| which it will try to download from the log webpages
    hosted at Warwick. You will need to know passwords to access these.

    If a target name is entered, it will first searched for in
    SIMBAD. If that fails, it will be searched for coordinates in the
    form "J123456.7-123456" or similar, so the latter is always the
    fallback for objects that don't appear in SIMBAD. It can also
    search by regular expression matching.

    Arguments::

       target : str
          Target name. On the command line, must be enclosed in quotes if it
          contains spaces. This will be used first to carry out a lookup in
          SIMBAD to find the RA and Dec. Failing this, it tries to identify
          coordinates from a final strength of the form JHHMMSS.S[+/-]DDMMSS
          Enter "none" to ignore.

       tmin : float
          Minimum exposure duration seconds to cut out short runs.

       dmax : float
          Maximum distance from lookup position, arcminutes

       regex : str
          Regular expression to use to try to match target names in
          addition to the coordinate matching. "none" to ignore.

       nocase : bool [if regex is not "none"]
          True for case-insensitive matching, else case-sensitive used
          with regex

       output : str
          Name of CSV file to store the results. 'none' to
          ignore. Usually you will want to specify this since the
          results are too wide to print to screen. Assuming you do
          save the results, they are best viewed in an excel-type
          programme or topcat, or they can be read programatically
          into a pandas Dataframe using pd.read_csv('results.csv').
          Column names from all instruments are concatenated which for
          instance means that a column appropriate for hipercam, might
          be blank for ULTRACAM and vice versa. An extra "Instrument"
          column is added to make the origin clear.

    .. Note::

       The program will attempt to download the databases from the
       Warwick server. Since they are often updated, it will always
       check, but only download if the server files are newer than the
       local versions. The downloads are stored in
       $HOME/.hipercam/dbases [or $HIPERCAM_ENV/dbases if you have set
       HIPERCAM_ENV].  You will need to know the passwords. They will be stored
       in your keyring in a folder called "Data logs". If the
       passwords change, you will have to delete those stored in your
       keyring.

    """

    command, args = utils.script_args(args)

    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:

        # register parameters
        cl.register("target", Cline.LOCAL, Cline.PROMPT)
        cl.register("dmax", Cline.LOCAL, Cline.PROMPT)
        cl.register("regex", Cline.LOCAL, Cline.PROMPT)
        cl.register("nocase", Cline.LOCAL, Cline.PROMPT)
        cl.register("tmin", Cline.LOCAL, Cline.PROMPT)
        cl.register("output", Cline.LOCAL, Cline.PROMPT)

        # get inputs
        target = cl.get_value(
            "target", "target name for simbad lookup ['none' to ignore]",
            "AR Sco", ignore="none"
        )

        if target is not None:
            dmax = cl.get_value(
                "dmax", "maximum distance from target [arcminutes]",
                12., 0.
            )

            regex = cl.get_value(
                "regex", "regular expression to match target name ['none' to ignore]",
                "none", ignore="none"
            )

        else:
            regex = cl.get_value(
                "regex", "regular expression to match target name",
                "ar\s*sco"
            )

        if regex is not None:
            nocase = cl.get_value(
                "nocase", "case insensitive match?", True
            )

        tmin = cl.get_value(
            "tmin", "minimum exposure duration for a run to be included [seconds]", -1.
        )

        output = cl.get_value(
            "output", "name of spreadsheet of results ['none' to ignore]",
            cline.Fname('results', '.csv', cline.Fname.NEW), ignore="none"
        )

    # Get database files.

    # First create directory for them if need be
    dbases_dir = os.path.join(
        os.environ.get(
            'HIPERCAM_ENV',
            os.path.join(os.environ["HOME"],'.hipercam')
        ),
        'dbases'
    )
    os.makedirs(dbases_dir, 0o700, True)

    # Then download them. Passwords will be prompted and, if the
    # subsequent download is successful, will be stored in the
    # system keyring

    server = 'https://cygnus.astro.warwick.ac.uk/phsaap/'

    dbases = []
    for dbase in ('ultracam', 'ultraspec', 'hipercam'):

        pword = keyring.get_password("Data logs", dbase)
        prompted = False
        if pword is None:
            pword = getpass.getpass(f'{dbase} logs password: ')
            prompted = True

        # accumulate list of files and equivalent table names
        fname = os.path.join(dbases_dir, f'{dbase}.db')
        dbases.append((fname, dbase))

        if pword != "":
            # use 'curl' to download
            args = [
                'curl','-u', f'{dbase}:{pword}','-o',fname,
                '-z',fname,f'{server}/{dbase}/logs/{dbase}.db'
            ]
            result = subprocess.run(
                args, capture_output=True, universal_newlines=True
            )
            if result.returncode and not os.path.exists(fname):
                raise hcam.HipercamError(
                    f'Failed to download {dbase}.db. Return from curl:'
                    + 'stdout={result.stdout}, stderr={result.stderr}'
                )
            elif result.returncode:
                print(
                    f'Failed to download {dbase}.db. Will use old'
                    'local copy although it may be out of date'
                )
            elif prompted:
                # successful, will store password in the keyring
                keyring.set_password("Data logs", dbase, pword)
                print(f' stored password for {dbase} in keyring')

            # check return from curl
            res = result.stderr.split('\n')
            diff = set(res[3].split())
            if '0' in diff and len(diff) == 2:
                print(f' {dbase}.db unchanged on server')
            else:
                print(f' {dbase}.db updated from server')
        else:
            print(f'No attempt to update {fname}')

    print()
    if target is not None:
        name, ra, dec = target_lookup(target)
        if name == 'UNDEF':
            print(f'Coordinate lookup for "{target}" failed')
            exit(1)

        print(
            f'Coordinate lookup for "{target}" returned name = "{name}", RA [hrs] = {ra}, Dec [deg] = {dec}'
        )

        field = dmax/60.
        ra *= 15
        cdec = np.cos(np.radians(dec))
        ralo = ra - field/cdec
        rahi = ra + field/cdec
        declo = dec - field
        dechi = dec + field

    results = []
    for dbase, dtable in dbases:

        # connect to database
        conn = sqlite3.connect(dbase)

        # build query string
        query = f'SELECT * FROM {dtable}\n'

        if target is not None:
            if dtable == 'ultracam':
                query += (
                    f"WHERE (ra_deg > {ralo} AND ra_deg < {rahi}\n"
                    f"AND dec_deg > {declo} AND dec_deg < {dechi}\n"
                    f"AND total > {tmin})\n"
                )
            else:
                query += (
                    f"WHERE ((ra_deg > {ralo} AND ra_deg < {rahi}\n"
                    f"AND dec_deg > {declo} AND dec_deg < {dechi}) OR\n"
                    f"(ra_tel_deg > {ralo} AND ra_tel_deg < {rahi}\n"
                    f"AND dec_tel_deg > {declo} AND dec_tel_deg < {dechi})\n"
                    f"AND total > {tmin})\n"
                )

            if regex is not None:
                conn.create_function("REGEXP", 2, regexp)
                query += f'OR (REGEXP("{regex}",target) AND total > {tmin})'

        else:
            conn.create_function("REGEXP", 2, regexp)
            query += f'WHERE (REGEXP("{regex}",target) AND total > {tmin})'

        print(f'\nQuerying {dbase}\n')
        res = pd.read_sql_query(query, conn)
        if len(res):
            print(res)
            res['Instrument'] = dtable
            results.append(res)
        else:
            print('   no runs found')

        # close connection
        conn.close()

    if output is not None:
        total = pd.concat(results)
        total.to_csv(output)

def regexp(expr, item):
    reg = re.compile(expr,re.IGNORECASE)
    return reg.search(item) is not None
