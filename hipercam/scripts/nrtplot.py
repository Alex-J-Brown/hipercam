import sys
import os
import time

import numpy as np

import matplotlib.pylab as plt
from matplotlib.animation import FuncAnimation

from astropy.time import Time

import hipercam as hcam
from hipercam import cline, utils, spooler, defect
from hipercam.cline import Cline
from hipercam.mpl import Params

import requests
import socket

__all__ = [
    "nrtplot",
]

######################################
#
# nrtplot -- display of multiple images
#
######################################


def nrtplot(args=None):
    """``nrtplot [source] (run first [twait tmax] | flist) trim ([ncol
    nrow]) (ccd (nx)) [pause plotall] bias [lowlevel highlevel] flat
    defect setup [drurl] msub iset (ilo ihi | plo phi) xlo xhi ylo yhi
    (profit [fdevice fwidth fheight method beta fwhm fwhm_min shbox
    smooth splot fhbox hmin read gain thresh])``

    This is 'nrtplot' "new" rtplot, intended as a matplotlib-based
    replacement for the current PGPLOT one. Under development.

    Plots a sequence of images as a movie in near 'real time', hence
    'rt'. Designed to be used to look at images coming in while at the
    telescope, 'rtplot' comes with many options, a large number of
    which are hidden by default, and many of which are only prompted
    if other arguments are set correctly. If you want to see them all,
    invoke as 'rtplot prompt'.  This is worth doing once to know
    rtplot's capabilities.

    rtplot can source data from both the ULTRACAM and HiPERCAM
    servers, from local 'raw' ULTRACAM and HiPERCAM files (i.e. .xml +
    .dat for ULTRACAM, 3D FITS files for HiPERCAM) and from lists of
    HiPERCAM '.hcm' files.

    rtplot optionally allows the selection of targets to be fitted
    with gaussian or moffat profiles, and, if successful, will plot
    circles of 2x the measured FWHM in green over the selected
    targets. This option only works if a single CCD is being plotted.

    Parameters:

        source : string [hidden]
           Data source, five options:

             |  'hs' : HiPERCAM server
             |  'hl' : local HiPERCAM FITS file
             |  'us' : ULTRACAM server
             |  'ul' : local ULTRACAM .xml/.dat files
             |  'hf' : list of HiPERCAM hcm FITS-format files

           'hf' is used to look at sets of frames generated by 'grab' or
           converted from foreign data formats. The standard start-off
           default for ``source'' can be set using the environment variable
           HIPERCAM_DEFAULT_SOURCE. e.g. in bash :code:`export HIPERCAM_DEFAULT_SOURCE="us"`
           would ensure it always started with the ULTRACAM server by default. If
           unspecified, it defaults to 'hl'.

        run : string [if source ends 's' or 'l']
           run number to access, e.g. 'run034'

        flist : string [if source ends 'f']
           name of file list

        first : int [if source ends 's' or 'l']
           exposure number to start from. 1 = first frame; set = 0 to always
           try to get the most recent frame (if it has changed).  For data
           from the |hiper| server, a negative number tries to get a frame not
           quite at the end.  i.e. -10 will try to get 10 from the last
           frame. This is mainly to sidestep a difficult bug with the
           acquisition system.

        twait : float [if source ends 's' or 'l'; hidden]
           time to wait between attempts to find a new exposure, seconds.

        tmax : float [if source ends 's' or 'l'; hidden]
           maximum time to wait between attempts to find a new exposure,
           seconds.

        trim : bool [if source starts with 'u']
           True to trim columns and/or rows off the edges of windows nearest
           the readout which can sometimes contain bad data.

        ncol : int [if trim, hidden]
           Number of columns to remove (on left of left-hand window, and right
           of right-hand windows)

        nrow : int [if trim, hidden]
           Number of rows to remove (bottom of windows)

        ccd : str
           CCD(s) to plot, '0' for all, '1 3' to plot '1' and '3' only, etc.

        nx : int [if more than 1 CCD]
           number of panels across to display.

        pause : float [hidden]
           seconds to pause between frames (defaults to 0). This is in addition
           to any time taken per frame to read and display it, so is just to slow
           things not to set an exact rate.

        plotall : bool [hidden]
           plot all frames regardless of status (i.e. including blank frames
           when nskips are enabled (defaults to False). The profile fitting
           will still be disabled for bad frames.

        bias : str
           Name of bias frame to subtract, 'none' to ignore.

        lowlevel : float [hidden]
           Level below which a warning about low bias levels is warned. Set=0
           to ignore. Applied to first window of first CCD. 2000 about
           right for ULTRACAM.

        highlevel : float [hidden]
           Level above which a warning about high bias levels is warned. Set=0
           to ignore. Applied to first window of first CCD. 3500 about
           right for ULTRACAM.

        flat : string
           Name of flat field to divide by, 'none' to ignore. Should normally
           only be used in conjunction with a bias, although it does allow you
           to specify a flat even if you haven't specified a bias.

        defect : string
           Name of defect file, 'none' to ignore.

        setup : bool
           True/yes to access the current windows from hdriver. Useful
           during observing when seeting up windows, but not normally
           otherwise. Next argument (hidden) is the URL to get to
           hdriver. Once setup, you should probably turn this off to
           avoid overloading hdriver, especially if in drift mode as
           it makes a request for the windows for every frame.

        drurl : string [if setup; hidden]
           URL needed to access window setting from the camera
           driver (ultracam, ultraspec, hipercam). The internal server 
           in the camera driver must be switched on which can be done
           from the GUI.

        msub : bool
           subtract the median from each window before scaling for the
           image display or not. This happens after any bias subtraction.

        iset : string [single character]
           determines how the intensities are determined. There are three
           options: 'a' for automatic simply scales from the minimum to the
           maximum value found on a per CCD basis. 'd' for direct just takes
           two numbers from the user. 'p' for percentile dtermines levels
           based upon percentiles determined from the entire CCD on a per CCD
           basis.

        ilo : float [if iset='d']
           lower intensity level

        ihi : float [if iset='d']
           upper intensity level

        plo : float [if iset='p']
           lower percentile level

        phi : float [if iset='p']
           upper percentile level

        xlo : float
           left-hand X-limit for plot

        xhi : float
           right-hand X-limit for plot (can actually be < xlo)

        ylo : float
           lower Y-limit for plot

        yhi : float
           upper Y-limit for plot (can be < ylo)

        profit : bool [if plotting a single CCD only]
           carry out profile fits or not. If you say yes, then on the first
           plot, you will have the option to pick objects with a cursor. The
           program will then attempt to track these from frame to frame, and
           fit their profile. You may need to adjust 'first' to see anything.
           The parameters used for profile fits are hidden and you may want to
           invoke the command with 'prompt' the first time you try profile
           fitting.

        fdevice : string [if profit; hidden]
           plot device for profile fits, PGPLOT-style name.
           e.g. '/xs', '2/xs' etc.

        fwidth : float [if profit; hidden]
           fit plot width (inches). Set = 0 to let the program choose.

        fheight : float [if profit; hidden]
           fit plot height (inches). Set = 0 to let the program choose.
           BOTH fwidth AND fheight must be non-zero to have any effect

        method : string [if profit; hidden]
           this defines the profile fitting method, either a gaussian or a
           moffat profile. The latter is usually best.

        beta : float [if profit and method == 'm'; hidden]
           default Moffat exponent

        fwhm : float [if profit; hidden]
           default FWHM, unbinned pixels.

        fwhm_min : float [if profit; hidden]
           minimum FWHM to allow, unbinned pixels.

        shbox : float [if profit; hidden]
           half width of box for searching for a star, unbinned pixels. The
           brightest target in a region +/- shbox around an intial position
           will be found. 'shbox' should be large enough to allow for likely
           changes in position from frame to frame, but try to keep it as
           small as you can to avoid jumping to different targets and to
           reduce the chances of interference by cosmic rays.

        smooth : float [if profit; hidden]
           FWHM for gaussian smoothing, binned pixels. The initial position
           for fitting is determined by finding the maximum flux in a smoothed
           version of the image in a box of width +/- shbox around the starter
           position. Typically should be comparable to the stellar width. Its
           main purpose is to combat cosmi rays which tend only to occupy a
           single pixel.

        splot : bool [if profit; hidden]
           Controls whether an outline of the search box and a target number
           is plotted (in red) or not.

        fhbox : float [if profit; hidden]
           half width of box for profile fit, unbinned pixels. The fit box is
           centred on the position located by the initial search. It should
           normally be > ~2x the expected FWHM.

        hmin : float [if profit; hidden]
           height threshold to accept a fit. If the height is below this
           value, the position will not be updated. This is to help in cloudy
           conditions.

        read : float [if profit; hidden]
           readout noise, RMS ADU, for assigning uncertainties

        gain : float [if profit; hidden]
           gain, ADU/count, for assigning uncertainties

        thresh : float [if profit; hidden]
           sigma rejection threshold for fits

    """

    command, args = utils.script_args(args)

    # get the inputs
    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:

        # register parameters
        cl.register("source", Cline.GLOBAL, Cline.HIDE)
        cl.register("run", Cline.GLOBAL, Cline.PROMPT)
        cl.register("first", Cline.LOCAL, Cline.PROMPT)
        cl.register("trim", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ncol", Cline.GLOBAL, Cline.HIDE)
        cl.register("nrow", Cline.GLOBAL, Cline.HIDE)
        cl.register("twait", Cline.LOCAL, Cline.HIDE)
        cl.register("tmax", Cline.LOCAL, Cline.HIDE)
        cl.register("flist", Cline.LOCAL, Cline.PROMPT)
        cl.register("ccd", Cline.LOCAL, Cline.PROMPT)
        cl.register("nx", Cline.LOCAL, Cline.PROMPT)
        cl.register("pause", Cline.LOCAL, Cline.HIDE)
        cl.register("plotall", Cline.LOCAL, Cline.HIDE)
        cl.register("bias", Cline.GLOBAL, Cline.PROMPT)
        cl.register("lowlevel", Cline.GLOBAL, Cline.HIDE)
        cl.register("highlevel", Cline.GLOBAL, Cline.HIDE)
        cl.register("flat", Cline.GLOBAL, Cline.PROMPT)
        cl.register("defect", Cline.GLOBAL, Cline.PROMPT)
        cl.register("setup", Cline.GLOBAL, Cline.PROMPT)
        cl.register("drurl", Cline.GLOBAL, Cline.HIDE)
        cl.register("msub", Cline.GLOBAL, Cline.PROMPT)
        cl.register("iset", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ilo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ihi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("plo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("phi", Cline.LOCAL, Cline.PROMPT)
        cl.register("xlo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("xhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ylo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("yhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("profit", Cline.LOCAL, Cline.PROMPT)
        cl.register("fdevice", Cline.LOCAL, Cline.HIDE)
        cl.register("fwidth", Cline.LOCAL, Cline.HIDE)
        cl.register("fheight", Cline.LOCAL, Cline.HIDE)
        cl.register("method", Cline.LOCAL, Cline.HIDE)
        cl.register("beta", Cline.LOCAL, Cline.HIDE)
        cl.register("fwhm", Cline.LOCAL, Cline.HIDE)
        cl.register("fwhm_min", Cline.LOCAL, Cline.HIDE)
        cl.register("shbox", Cline.LOCAL, Cline.HIDE)
        cl.register("smooth", Cline.LOCAL, Cline.HIDE)
        cl.register("splot", Cline.LOCAL, Cline.HIDE)
        cl.register("fhbox", Cline.LOCAL, Cline.HIDE)
        cl.register("hmin", Cline.LOCAL, Cline.HIDE)
        cl.register("read", Cline.LOCAL, Cline.HIDE)
        cl.register("gain", Cline.LOCAL, Cline.HIDE)
        cl.register("thresh", Cline.LOCAL, Cline.HIDE)

        # get inputs
        default_source = os.environ.get('HIPERCAM_DEFAULT_SOURCE','hl')
        source = cl.get_value(
            "source",
            "data source [hs, hl, us, ul, hf]",
            default_source,
            lvals=("hs", "hl", "us", "ul", "hf"),
        )

        # set some flags
        server_or_local = source.endswith("s") or source.endswith("l")

        if server_or_local:
            resource = cl.get_value("run", "run name", "run005")
            if source == "hs":
                first = cl.get_value("first", "first frame to plot", 1)
            else:
                first = cl.get_value("first", "first frame to plot", 1, 0)

            twait = cl.get_value(
                "twait", "time to wait for a new frame [secs]", 1.0, 0.0
            )
            tmax = cl.get_value(
                "tmax", "maximum time to wait for a new frame [secs]", 10.0, 0.0
            )

        else:
            resource = cl.get_value(
                "flist", "file list", cline.Fname("files.lis", hcam.LIST)
            )
            first = 1

        trim = cl.get_value("trim", "do you want to trim edges of windows?", True)
        if trim:
            ncol = cl.get_value("ncol", "number of columns to trim from windows", 0)
            nrow = cl.get_value("nrow", "number of rows to trim from windows", 0)
        else:
            ncol, nrow = None, None

        # define the panel grid. first get the labels and maximum dimensions
        ccdinf = spooler.get_ccd_pars(source, resource)

        try:
            nxdef = cl.get_default("nx")
        except:
            nxdef = 3

        if len(ccdinf) > 1:
            ccd = cl.get_value("ccd", "CCD(s) to plot [0 for all]", "0")
            if ccd == "0":
                ccds = list(ccdinf.keys())
            else:
                ccds = ccd.split()
                check = set(ccdinf.keys())
                if not set(ccds) <= check:
                    raise hcam.HipercamError("At least one invalid CCD label supplied")

            if len(ccds) > 1:
                nxdef = min(len(ccds), nxdef)
                cl.set_default("nx", nxdef)
                nx = cl.get_value("nx", "number of panels in X", 3, 1)
            else:
                nx = 1
        else:
            nx = 1
            ccds = list(ccdinf.keys())

        cl.set_default("pause", 0.0)
        pause = cl.get_value(
            "pause", "time delay to add between" " frame plots [secs]", 0.0, 0.0
        )

        cl.set_default("plotall", False)
        plotall = cl.get_value(
            "plotall", "plot all frames," " regardless of status?", False
        )

        # bias frame (if any)
        bias = cl.get_value(
            "bias",
            "bias frame ['none' to ignore]",
            cline.Fname("bias", hcam.HCAM),
            ignore="none",
        )
        if bias is not None:
            # read the bias frame
            bias = hcam.MCCD.read(bias)
            fprompt = "flat frame ['none' to ignore]"
        else:
            fprompt = "flat frame ['none' is normal choice with no bias]"

        lowlevel = cl.get_value(
            "lowlevel", "bias level lower limit for warnings", 2000.0
        )

        highlevel = cl.get_value(
            "highlevel", "bias level upper limit for warnings", 3500.0
        )

        # flat (if any)
        flat = cl.get_value(
            "flat", fprompt, cline.Fname("flat", hcam.HCAM), ignore="none"
        )
        if flat is not None:
            # read the flat frame
            flat = hcam.MCCD.read(flat)

        # defect file (if any)
        dfct = cl.get_value(
            "defect",
            "defect file ['none' to ignore]",
            cline.Fname("defect", hcam.DFCT),
            ignore="none",
        )
        if dfct is not None:
            # read the defect frame
            dfct = defect.MccdDefect.read(dfct)

        # Get windows from hdriver
        setup = cl.get_value("setup", "display current hdriver window settings", False)

        if setup:
            drurl = cl.get_value(
                "drurl", "URL for driver windows", "http://192.168.1.2:5100"
            )

        # define the display intensities
        msub = cl.get_value("msub", "subtract median from each window?", True)

        iset = cl.get_value(
            "iset",
            "set intensity a(utomatically)," " d(irectly) or with p(ercentiles)?",
            "a",
            lvals=["a", "d", "p"],
        )
        iset = iset.lower()

        plo, phi = 5, 95
        ilo, ihi = 0, 1000
        if iset == "d":
            ilo = cl.get_value("ilo", "lower intensity limit", 0.0)
            ihi = cl.get_value("ihi", "upper intensity limit", 1000.0)
        elif iset == "p":
            plo = cl.get_value(
                "plo", "lower intensity limit percentile", 5.0, 0.0, 100.0
            )
            phi = cl.get_value(
                "phi", "upper intensity limit percentile", 95.0, 0.0, 100.0
            )

        # region to plot
        for i, cnam in enumerate(ccds):
            nxtot, nytot, nxpad, nypad = ccdinf[cnam]
            if i == 0:
                xmin, xmax = float(-nxpad), float(nxtot + nxpad + 1)
                ymin, ymax = float(-nypad), float(nytot + nypad + 1)
            else:
                xmin = min(xmin, float(-nxpad))
                xmax = max(xmax, float(nxtot + nxpad + 1))
                ymin = min(ymin, float(-nypad))
                ymax = max(ymax, float(nytot + nypad + 1))

        xlo = cl.get_value("xlo", "left-hand X value", xmin, xmin, xmax)
        xhi = cl.get_value("xhi", "right-hand X value", xmax, xmin, xmax)
        ylo = cl.get_value("ylo", "lower Y value", ymin, ymin, ymax)
        yhi = cl.get_value("yhi", "upper Y value", ymax, ymin, ymax)

        # profile fitting if just one CCD chosen
        if len(ccds) == 1:
            # many parameters for profile fits, although most are not plotted
            # by default
            profit = cl.get_value("profit", "do you want profile fits?", False)

            if profit:
                fdevice = cl.get_value("fdevice", "plot device for fits", "2/xs")
                fwidth = cl.get_value("fwidth", "fit plot width (inches)", 0.0)
                fheight = cl.get_value("fheight", "fit plot height (inches)", 0.0)
                method = cl.get_value(
                    "method", "fit method g(aussian) or m(offat)", "m", lvals=["g", "m"]
                )
                if method == "m":
                    beta = cl.get_value(
                        "beta", "initial exponent for Moffat fits", 5.0, 0.5, 20.
                    )
                else:
                    beta = 0.0
                fwhm_min = cl.get_value(
                    "fwhm_min", "minimum FWHM to allow [unbinned pixels]", 1.5, 0.01
                )
                fwhm = cl.get_value(
                    "fwhm",
                    "initial FWHM [unbinned pixels] for profile fits",
                    6.0,
                    fwhm_min,
                )
                shbox = cl.get_value(
                    "shbox",
                    "half width of box for initial location"
                    " of target [unbinned pixels]",
                    11.0,
                    2.0,
                )
                smooth = cl.get_value(
                    "smooth",
                    "FWHM for smoothing for initial object"
                    " detection [binned pixels]",
                    6.0,
                )
                splot = cl.get_value("splot", "plot outline of search box?", True)
                fhbox = cl.get_value(
                    "fhbox",
                    "half width of box for profile fit" " [unbinned pixels]",
                    21.0,
                    3.0,
                )
                hmin = cl.get_value(
                    "hmin", "minimum peak height to accept the fit", 50.0
                )
                read = cl.get_value("read", "readout noise, RMS ADU", 3.0)
                gain = cl.get_value("gain", "gain, ADU/e-", 1.0)
                thresh = cl.get_value("thresh", "number of RMS to reject at", 4.0)

        else:
            profit = False

    ###############################################################################

    # Phew. We finally have all the inputs and now can now display stuff. Most of the
    # hard work is devolved to the Animator class below.


    # Define config
    nccd = len(ccds)
    ny = nccd // nx if nccd % nx == 0 else nccd // nx + 1

    fig, axs = plt.subplots(ny,nx)

    # define the source of images (spool)
    with spooler.data_source(source, resource, first, full=False) as spool:

        # Create the animator
        animator = Animator(
            axs, spool, server_or_local, ccds, xlo, xhi, ylo, yhi,
            time, ncol, nrow, lowlevel, highlevel, setup, drurl,
            plotall, msub, iset, ilo, ihi, plo phi
        )

        # Animate
        anim = FuncAnimation(fig, animator, interval=1000*pause, blit=True)

        plt.show()


# From here is support code not visible outside

class Animator:
    """
    Function object class to enable use of matplotlib.animation.FuncAnimation.
    Basic idea is that initialising it stores all the very many inputs as
    attributes and creates the plot, then the __call__ method allows it to be
    used as a function, and so passed as the `func` argument of
    maplotlib.animation.FuncAnimation. The purpose of the call method is to update
    the plot and return a list of updated elements.
    """

    def __init__(
            self, axs, spool, server_or_local, twait, tmax, ccds,
            xlo, xhi, ylo, yhi, trim, ncol, nrow, lowlevel, highlevel,
            setup, drurl, plotall, msub, iset, ilo, ihi, plo, phi):
        """
        Initialises the plot. Arguments:

          axs : list of Axes
             all the axes of the plot.

          spool : SpoolerBase
             source of images to display

          server_or_local : bool
             True if accessing the data through a server where data
             is assumed to accumulate to we wait

          twait : float
             How long to wait between attempts to get the next frame (seconds)

          tmax : float
             Maximum time to wait between attempts to get the next frame (seconds)

          ccds : list of strings
             CCD names to plot

          xlo : float
             left-hand limit of region to display

          xhi : float
             right-hand limit of region to display

          ylo : float
             lower limit of region to display

          yhi : float
             upper limit of region to display

          trim : bool
             whether to trim the frames

          ncol : int
             number of columns, if trim

          nrow : int
             number of rows, if trim

          lowlevel : float
             level to warn of a low bias level

          highlevel : float
             level to warn of a high bias level

          setup : bool
             whether to try to get setup windows from the camera driver

          drurl : str
             the URL to use to get the setup windows

          plotall : bool
             whether to plot every image whether bad or not

          msub : bool
             subtract median or not

          iset : str
             method of intensity computation

          ilo : float
             low level of direct intensity display (if iset='d')

          ihi : float
             high level of direct intensity display (if iset='d')

          plo : float
             low percentile (if iset='p')

          phi : float
             high percentile (if iset='p')

        """

        # Save the inputs
        self.axs = axs
        self.spool = spool
        self.server_or_local = server_or_local
        self.bias = bias
        self.flat = flat
        self.twait = twait
        self.tmax = tmax
        self.ccds = ccds
        self.extent = extent
        self.xlo = xlo
        self.xlo = xhi
        self.xlo = ylo
        self.yhi = yhi
        self.trim = trim
        self.ncol = ncol
        self.nrow = nrow
        self.lowlevel = lowlevel
        self.highlevel = highlevel
        self.setup = setup
        self.drurl = drurl
        self.plotall = plotall
        self.msub = msub
        self.iset = iset
        self.ilo = ilo
        self.ihi = ihi
        self.plo = plo
        self.phi = phi

        # set frame counter
        self.nframe = 0

        # initialise dictionary where changing image references are stored
        # this will be keyed by CCD name
        self.wimages = {}

        # Initialise the plot

        # First sync the axes
        ax0 = self.axs.flat[0]
        for ax in self.axs.flat[1:len(self.ccds)]:
            ax.sharex(ax0)
            ax.sharey(ax0)
        ax0.set_xlim(xlo,xhi)
        ax0.set_ylim(ylo,yhi)

        # Display first frame
        self.__call__(0)

    def __call__(self, n):

        fpos = []  # list of target positions to fit
        fframe = True  # waiting for first valid frame with profit

        mccd, emessages = self.get_next_frame()

        if self.setup:
            # Get windows from driver. Fair bit of error checking
            # needed. 'got_windows' indicates if anything useful
            # found, 'hwindows' is a list of (llx,lly,nx,ny) tuples
            # if somthing is found.
            try:
                r = requests.get(self.drurl, timeout=0.2)

                if r.text.strip() == "No valid data available":
                    emessages.append(
                        f"** bad return from hdriver = {r.text.strip()}"
                    )
                    got_windows = False

                elif r.text.strip() == "fullframe":
                    # to help Stu out a bit, effectively just
                    # ignore this one
                    got_windows = False

                else:
                    # OK, got something
                    got_windows = True
                    lines = r.text.split("\r\n")
                    xbinh, ybinh, nwinh = lines[0].split()
                    xbinh, ybinh, nwinh = int(xbinh), int(ybinh), int(nwinh)
                    hwindows = []
                    for line in lines[1 : nwinh + 1]:
                        llxh, llyh, nxh, nyh = line.split()
                        hwindows.append((int(llxh), int(llyh), int(nxh), int(nyh)))

                    if nwinh != len(hwindows):
                        emessages.append(
                            f"** expected {nwinh} windows from hdriver but got {len(windows)}"
                        )
                        got_windows = False

            except (
                    requests.exceptions.ConnectionError,
                    socket.timeout,
                    requests.exceptions.Timeout,
            ) as err:
                emessages.append(f" ** hdriver error: {err}")
                got_windows = False

        else:
            got_windows = False

        # display the CCDs
        message = ""

        artists = []
        for nc, (cnam, axes) in enumerate(ccds, self.axs.flat):
            ccd = mccd[cnam]

            if self.plotall or ccd.is_data():
                # this should be data as opposed to a blank frame
                # between data frames that occur with nskip > 0

                # subtract the bias
                if self.bias is not None:
                    ccd -= self.bias[cnam]

                # divide out the flat
                if self.flat is not None:
                    ccd /= self.flat[cnam]

                if self.msub:
                    # subtract median from each window
                    for wind in ccd.values():
                        wind -= wind.median()

                if cnam in self.wimages:
                    # updating images
                    wimages = self.disp_ccd(axes, ccd[cnam], cnam, self.wimages[cnam])
                else:
                    # creating images
                    wimages = self.disp_ccd(axes, ccd, cnam)
                    self.wimages[cnam] = wimages

                # maintain an overall list of artists that have changed
                artists += wimages


                #                if got_windows:
                #                    # plot the current hdriver windows
                #                    pgsci(hcam.CNAMS["green"])
                #                    pgsls(2)
                #                    for llxh, llyh, nxh, nyh in hwindows:
                #                        pgrect(
                #                            llxh - 0.5,
                #                            llxh + nxh - 0.5,
                #                            llyh - 0.5,
                #                            llyh + nyh - 0.5,
                #                        )

                #                    if dfct is not None and cnam in dfct:
                #                        # plot defects
                #                        hcam.pgp.pCcdDefect(dfct[cnam])

                #                    # accumulate string of image scalings
                #                    if nc:
                #                        message += ", ccd {:s}: {:.1f}, {:.1f}, exp: {:.4f}".format(
                #                            cnam, vmin, vmax, mccd.head["EXPTIME"]
                #                        )
                #                    else:
                #                        message += "ccd {:s}: {:.1f}, {:.1f}, exp: {:.4f}".format(
                #                            cnam, vmin, vmax, mccd.head["EXPTIME"]
                #                        )

        # end of CCD display loop
        print(message)
        for emessage in emessages:
            print(emessage)

        # this is where cursor selection of targets to aperture fit
        # might need to be

        # return the list of modified artists, which lies at the heart
        # of the animation.
        return artists

    def get_next_frame(self):
        """
        Gets the next data frame.

        Returns (mccd, emessages)

        emessages is a list of any warning messages.

        Raises a StopIteration when it hits the buffers.
        """

        total_time = 0
        while 1:
            # try to get frame
            mccd = next(self.spool)

            if self.server_or_local:
                # Handle the waiting game ...
                give_up, try_again, total_time = spooler.hang_about(
                    mccd, self.twait, self.tmax, total_time
                )

                if give_up:
                    raise StopIteration
                elif try_again:
                    continue
                else:
                    break

        # Trim the frames: ULTRACAM windowed data has bad columns
        # and rows on the sides of windows closest to the readout
        # which can badly affect reduction. This option strips
        # them.
        if self.trim:
            hcam.ccd.trim_ultracam(mccd, self.ncol, self.nrow)

        # indicate progress
        tstamp = Time(mccd.head["TIMSTAMP"], format="isot", precision=3)
        print(
            "{:d}, utc= {:s} ({:s}), ".format(
                mccd.head.get("NFRAME",self.nframe+1),
                tstamp.iso,
                "ok" if mccd.head.get("GOODTIME", True) else "nok",
            ),
            end="",
        )

        # accumulate errors
        emessages = []

        # bias level checks
        if self.lowlevel != 0.0:
            median = mccd.get_num(0).get_num(0).median()
            if median < self.lowlevel:
                emessages.append(
                    "** low bias level, median vs limit: {:.1f} vs {:.1f}".format(
                        median, self.lowlevel
                    )
                )

        if self.highlevel != 0.0:
            try:
                median = mccd.get_num(0).get_num(1).median()
            except:
                median = mccd.get_num(0).get_num(0).median()

            if median > self.highlevel:
                emessages.append(
                    "** high bias level, median vs limit: {:.1f} vs {:.1f}".format(
                            median, lowlevel
                        )
                    )

        if self.nframe == 0:
            # crop bias and flat on the first frame

            if self.bias is not None:
                self.bias = self.bias.crop(mccd)

            if self.flat is not None:
                self.flat = self.flat.crop(mccd)

        return (mccd,emessages)

    def disp_ccd(self, axes, ccd, cnam, wimages=None):
        """Displays a CCD ccd, name cnam, in Axes axes.

        If "wimages" is None, a list of images for each window
        (result of calling imshow) will be created and returned.
        Otherwise wimages is assumed to be such a list and they
        will be updated.
        """

        # compute display levels
        if self.iset == "p":
            # Set intensities from percentiles
            if self.xlo is not None and self.xhi is not None:
                xlo = min(self.xlo, self.xhi)
                xhi = max(self.xlo, self.xhi)
            if ylo is not None and yhi is not None:
                ylo = min(ylo, yhi)
                yhi = max(ylo, yhi)
            vmin, vmax = ccd.percentile(
                (self.plo, self.phi), xlo, xhi, ylo, yhi
            )
        elif iset == "a":
            # Set intensities from min/max range
            vmin, vmax = ccd.min(), ccd.max()
        elif iset == "d":
            vmin, vmax = self.ilo, self.ihi
        else:
            raise ValueError(f'did not recognise iset = "{self.iset}"')

        if wimages is None:
            # in this case we are setting up for the first time
            wimages = []
            for wnam, wind in ccd.items():
                left, right, bottom, top = wind.extent()

                # Display the images of each window (variable)
                wimages.append(
                    axes.imshow(
                        wind.data,
                        extent=(left, right, bottom, top),
                        aspect="equal",
                        origin="lower",
                        cmap="Greys",
                        interpolation="nearest",
                        vmin=vmin,
                        vmax=vmax,
                    )
                )

                # Plot boundary on window (fixed)
                axes.plot(
                    [left, right, right, left, left],
                    [bottom, bottom, top, top, bottom],
                    color=Params["win.box.col"],
                )

                # Label them (fixed)
                axes.text(
                    left - 3,
                    bottom - 3,
                    wban,
                    fontsize=Params["win.label.fs"],
                    color=Params["win.label.col"],
                    ha="right",
                    va="top",
                    clip_on=True,
                )

            # Plot outermost border of CCD (fixed)
            axes.plot(
                [0.5, ccd.nxtot + 0.5, ccd.nxtot + 0.5, 0.5, 0.5],
                [0.5, 0.5, ccd.nytot + 0.5, ccd.nytot + 0.5, 0.5],
                color=Params["ccd.box.col"],
            )

            # Set title and axis labels (fixed)
            axes.set_title(
                f'CCD {cnam}',
                color=Params["axis.label.col"], fontsize=Params["axis.label.fs"]
            )
            axes.set_xlabel(
                "X", color=Params["axis.label.col"], fontsize=Params["axis.label.fs"]
            )
            axes.set_ylabel(
                "Y", color=Params["axis.label.col"], fontsize=Params["axis.label.fs"]
            )


        else:
            # this is the "usual" post-setup case where we just
            # update the data of the images for each window
            for wind, wimg in zip(ccd.values(), wimages):
                wimg.set_data(wind.data)

    return wimages


