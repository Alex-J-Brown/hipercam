import sys
import os
import time

import numpy as np

import matplotlib.pylab as plt
from matplotlib.patches import Circle

from astropy.time import Time

import hipercam as hcam
from hipercam import cline, utils, spooler, defect
from hipercam.cline import Cline
from hipercam.mpl import Params

import requests
import socket

# colour for setup windows. works for me at least
# but may need input from Stu
COL_SETUP = (0.8, 0., 0.)

__all__ = [
    "nrtplot",
]

######################################
#
# nrtplot -- display of multiple images
#
######################################


def nrtplot(args=None):
    """``nrtplot [source] (run first [twait tmax] | flist) trim ([ncol
    nrow]) (ccd (nx)) [imwidth pause plotall] bias [lowlevel
    highlevel] flat defect setup [drurl cmap imwidth imheight] msub
    iset (ilo ihi | plo phi) xlo xhi ylo yhi profit ([method beta fwhm
    fwhm_min shbox smooth fhbox hmin read gain thresh fwnmax fwymax
    fwwidth fwheight]) ``

    This is 'nrtplot' "new" rtplot, a matplotlib-based replacement for
    the current PGPLOT one. Under development.

    Plots a sequence of images as a movie in near 'real time', hence
    'rt'. Designed to be used to look at images coming in while at the
    telescope, 'rtplot' comes with many options, a large number of
    which are hidden by default, and many of which are only prompted
    if other arguments are set correctly. If you want to see them all,
    invoke as 'rtplot prompt'.  This is worth doing once to know
    rtplot's capabilities. 

    rtplot can source data from both the ULTRACAM and HiPERCAM
    servers, from local 'raw' ULTRACAM and HiPERCAM files (i.e. .xml +
    .dat for ULTRACAM, 3D FITS files for HiPERCAM) and from lists of
    HiPERCAM '.hcm' files.

    rtplot optionally allows the selection of targets to be fitted
    with gaussian or moffat profiles, and, if successful, will plot
    circles of 2x the measured FWHM in green over the selected
    targets. In this case it can also plot the history of the FWHMs as
    an aid to focussing.

    Parameters:

        source : str [hidden]
           Data source, five options:

             |  'hs' : HiPERCAM server
             |  'hl' : local HiPERCAM FITS file
             |  'us' : ULTRACAM server
             |  'ul' : local ULTRACAM .xml/.dat files
             |  'hf' : list of HiPERCAM hcm FITS-format files

           'hf' is used to look at sets of frames generated by 'grab' or
           converted from foreign data formats. The standard start-off
           default for ``source'' can be set using the environment variable
           HIPERCAM_DEFAULT_SOURCE. e.g. in bash :code:`export HIPERCAM_DEFAULT_SOURCE="us"`
           would ensure it always started with the ULTRACAM server by default. If
           unspecified, it defaults to 'hl'.

        cmap : str [hidden]
           The matplotlib colour map to use. "Greys" gives the usual greyscale.
           "none" will give whatever the current default is. Many other choices:
           "viridis", "jet", "hot", "Oranges", etc. Enter an invalid one and
           the program will fail but return a huge list of possibles in the
           process. Note that some will not work well with the colours used
           to plot annotations.

        imwidth : float [hidden]
           image display plot width in inches (0 for default, and note
           that this will also make the height go to its default)

        imheight : float [hidden]
           image display plot height in inches (0 for default, and note
           that this will also make the width go to its default)

        run : str [if source ends 's' or 'l']
           run number to access, e.g. 'run034'

        flist : str [if source ends 'f']
           name of file list

        first : int [if source ends 's' or 'l']
           exposure number to start from. 1 = first frame; set = 0 to always
           try to get the most recent frame (if it has changed).  For data
           from the |hiper| server, a negative number tries to get a frame not
           quite at the end.  i.e. -10 will try to get 10 from the last
           frame. This is mainly to sidestep a difficult bug with the
           acquisition system.

        twait : float [if source ends 's' or 'l'; hidden]
           time to wait between attempts to find a new exposure, seconds.

        tmax : float [if source ends 's' or 'l'; hidden]
           maximum time to wait between attempts to find a new exposure,
           seconds.

        trim : bool [if source starts with 'u']
           True to trim columns and/or rows off the edges of windows nearest
           the readout which can sometimes contain bad data.

        ncol : int [if trim, hidden]
           Number of columns to remove (on left of left-hand window, and right
           of right-hand windows)

        nrow : int [if trim, hidden]
           Number of rows to remove (bottom of windows)

        ccd : str
           CCD(s) to plot, '0' for all, '1 3' to plot '1' and '3' only, etc.

        nx : int [if more than 1 CCD]
           number of panels across to display for the image display.

        pause : float [hidden]
           seconds to pause between frames (defaults to 0). This is in addition
           to any time taken per frame to read and display it, so is just to slow
           things not to set an exact rate.

        plotall : bool [hidden]
           plot all frames regardless of status (i.e. including blank frames
           when nskips are enabled (defaults to False). The profile fitting
           will still be disabled for bad frames.

        bias : str
           Name of bias frame to subtract, 'none' to ignore.

        lowlevel : float [hidden]
           Level below which a warning about low bias levels is warned. Set=0
           to ignore. Applied to first window of first CCD. 2000 about
           right for ULTRACAM.

        highlevel : float [hidden]
           Level above which a warning about high bias levels is warned. Set=0
           to ignore. Applied to first window of first CCD. 3500 about
           right for ULTRACAM.

        flat : str
           Name of flat field to divide by, 'none' to ignore. Should normally
           only be used in conjunction with a bias, although it does allow you
           to specify a flat even if you haven't specified a bias.

        defect : str
           Name of defect file, 'none' to ignore.

        setup : bool
           True/yes to access the current windows from hdriver. Useful
           during observing when setting up windows, but not normally
           otherwise. Next argument (hidden) is the URL to get to
           hdriver. Once setup, you should probably turn this off to
           avoid overloading hdriver, especially if in drift mode as
           it makes a request for the windows for every frame.

        drurl : str [if setup; hidden]
           URL needed to access window setting from the camera
           driver (ultracam, ultraspec, hipercam). The internal server
           in the camera driver must be switched on which can be done
           from the GUI.

        msub : bool
           subtract the median from each window before scaling for the
           image display or not. This happens after any bias subtraction.

        iset : str [single character]
           determines how the intensities are determined. There are three
           options: 'a' for automatic simply scales from the minimum to the
           maximum value found on a per CCD basis. 'd' for direct just takes
           two numbers from the user. 'p' for percentile dtermines levels
           based upon percentiles determined from the entire CCD on a per CCD
           basis.

        ilo : float [if iset='d']
           lower intensity level

        ihi : float [if iset='d']
           upper intensity level

        plo : float [if iset='p']
           lower percentile level

        phi : float [if iset='p']
           upper percentile level

        xlo : float
           left-hand X-limit for plot, initially at least since it is
           possible to re-size. For iset='p' these limits also set the
           region of the frame over which the percentil will be
           calculated. You will usually want yhi-ylo ~ xhi-xlo in
           magnitude because the aspect ratio is preserved.

        xhi : float
           right-hand X-limit for plot (can be < xlo to invert the display)

        ylo : float
           lower Y-limit for plot

        yhi : float
           upper Y-limit for plot (can be < ylo)

        profit : bool
           carry out profile fits or not. If you say yes, then you
           will get the option of selecting objects with a cursor. The
           program will then attempt to track these from frame to
           frame, and fit their profile. You may need to adjust
           'first' to see anything.  The parameters used for profile
           fits are hidden and you may want to invoke the command with
           'prompt' the first time you try profile fitting.

        method : str [if profit; hidden]
           this defines the profile fitting method, either a gaussian or a
           moffat profile. The latter is usually best.

        beta : float [if profit and method == 'm'; hidden]
           default Moffat exponent

        fwhm : float [if profit; hidden]
           default FWHM, unbinned pixels.

        fwhm_min : float [if profit; hidden]
           minimum FWHM to allow, unbinned pixels.

        shbox : float [if profit; hidden]
           half width of box for searching for a star, unbinned pixels. The
           brightest target in a region +/- shbox around an intial position
           will be found. 'shbox' should be large enough to allow for likely
           changes in position from frame to frame, but not too large to avoid
           jumping to brighter targets or possiblt cosmic rays.

        smooth : float [if profit; hidden]
           FWHM for gaussian smoothing, binned pixels. The initial position
           for fitting is determined by finding the maximum flux in a smoothed
           version of the image in a box of width +/- shbox around the starter
           position. Typically should be comparable to the stellar width. Its
           main purpose is to combat cosmic rays which tend only to occupy a
           single pixel.

        fhbox : float [if profit; hidden]
           half width of box for profile fit, unbinned pixels. The fit box is
           centred on the position located by the initial search. It should
           normally be > ~2x the expected FWHM, and usually smaller than shbox

        hmin : float [if profit; hidden]
           height threshold to accept a fit. If the height is below this
           value, the position will not be updated. This is to help in cloudy
           conditions. The limit is applied to the image after it has been
           smoothed to make less vulnerable to seeing fluctuations. This
           can mean it can be quite small.

        read : float [if profit; hidden]
           readout noise, RMS ADU, for assigning uncertainties

        gain : float [if profit; hidden]
           gain, ADU/count, for assigning uncertainties

        thresh : float [if profit; hidden]
           sigma rejection threshold for fits

        fwnmax : int [if profit; hidden]
           maximum number of frames to buffer the FWHM plot (< 2 ==>
           no plot). It allows the FWHMs of multiple stars to be
           tracked which might be useful for focussing. The plot
           starts to "slide" once the buffers are filled.

        fwymax : float [if profit; hidden]
           maximum FWHM to plot on Y-axis [unbinned pixels]. It is
           possible to alter the value of the fly by zooming and panning
           the plot.

        fwwidth : float [if profit; hidden]
           FWHM display plot width in inches (0 for default, which will
           also cause the height to go to its default value)

        fwheight : float [if profit; hidden]
           FWHM display plot height in inches (0 for default, which will
           also cause the width to go to its default value)

    """

    command, args = utils.script_args(args)

    # get the inputs
    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:

        # register parameters
        cl.register("source", Cline.GLOBAL, Cline.HIDE)
        cl.register("cmap", Cline.LOCAL, Cline.HIDE)
        cl.register("imwidth", Cline.LOCAL, Cline.HIDE)
        cl.register("imheight", Cline.LOCAL, Cline.HIDE)
        cl.register("run", Cline.GLOBAL, Cline.PROMPT)
        cl.register("first", Cline.LOCAL, Cline.PROMPT)
        cl.register("trim", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ncol", Cline.GLOBAL, Cline.HIDE)
        cl.register("nrow", Cline.GLOBAL, Cline.HIDE)
        cl.register("twait", Cline.LOCAL, Cline.HIDE)
        cl.register("tmax", Cline.LOCAL, Cline.HIDE)
        cl.register("flist", Cline.LOCAL, Cline.PROMPT)
        cl.register("ccd", Cline.LOCAL, Cline.PROMPT)
        cl.register("nx", Cline.LOCAL, Cline.PROMPT)
        cl.register("pause", Cline.LOCAL, Cline.HIDE)
        cl.register("plotall", Cline.LOCAL, Cline.HIDE)
        cl.register("bias", Cline.GLOBAL, Cline.PROMPT)
        cl.register("lowlevel", Cline.GLOBAL, Cline.HIDE)
        cl.register("highlevel", Cline.GLOBAL, Cline.HIDE)
        cl.register("flat", Cline.GLOBAL, Cline.PROMPT)
        cl.register("defect", Cline.GLOBAL, Cline.PROMPT)
        cl.register("setup", Cline.GLOBAL, Cline.PROMPT)
        cl.register("drurl", Cline.GLOBAL, Cline.HIDE)
        cl.register("msub", Cline.GLOBAL, Cline.PROMPT)
        cl.register("iset", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ilo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ihi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("plo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("phi", Cline.LOCAL, Cline.PROMPT)
        cl.register("xlo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("xhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ylo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("yhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("profit", Cline.LOCAL, Cline.PROMPT)
        cl.register("nxf", Cline.LOCAL, Cline.HIDE)
        cl.register("method", Cline.LOCAL, Cline.HIDE)
        cl.register("beta", Cline.LOCAL, Cline.HIDE)
        cl.register("fwhm", Cline.LOCAL, Cline.HIDE)
        cl.register("fwhm_min", Cline.LOCAL, Cline.HIDE)
        cl.register("shbox", Cline.LOCAL, Cline.HIDE)
        cl.register("smooth", Cline.LOCAL, Cline.HIDE)
        cl.register("fhbox", Cline.LOCAL, Cline.HIDE)
        cl.register("hmin", Cline.LOCAL, Cline.HIDE)
        cl.register("read", Cline.LOCAL, Cline.HIDE)
        cl.register("gain", Cline.LOCAL, Cline.HIDE)
        cl.register("thresh", Cline.LOCAL, Cline.HIDE)
        cl.register("fwnmax", Cline.LOCAL, Cline.HIDE)
        cl.register("fwymax", Cline.LOCAL, Cline.HIDE)
        cl.register("fwwidth", Cline.LOCAL, Cline.HIDE)
        cl.register("fwheight", Cline.LOCAL, Cline.HIDE)

        # get inputs
        default_source = os.environ.get('HIPERCAM_DEFAULT_SOURCE','hl')
        source = cl.get_value(
            "source",
            "data source [hs, hl, us, ul, hf]",
            default_source,
            lvals=("hs", "hl", "us", "ul", "hf"),
        )

        # Some settings for the imaghe plots
        cmap = cl.get_value("cmap", "colour map to use ['none' for mpl default]", "Greys")
        cmap = None if cmap == "none" else cmap

        imwidth = cl.get_value(
            "imwidth", "image plot width [inches, 0 for default]", 0., 0.
        )

        imheight = cl.get_value(
            "imheight", "image plot height [inches, 0 for default]", 0., 0.
        )

        # set some flags
        server_or_local = source.endswith("s") or source.endswith("l")

        if server_or_local:
            resource = cl.get_value("run", "run name", "run005")
            if source == "hs":
                first = cl.get_value("first", "first frame to plot", 1)
            else:
                first = cl.get_value("first", "first frame to plot", 1, 0)

            twait = cl.get_value(
                "twait", "time to wait for a new frame [secs]", 1.0, 0.0
            )
            tmax = cl.get_value(
                "tmax", "maximum time to wait for a new frame [secs]", 10.0, 0.0
            )

        else:
            resource = cl.get_value(
                "flist", "file list", cline.Fname("files.lis", hcam.LIST)
            )
            first = 1

        trim = cl.get_value("trim", "do you want to trim edges of windows?", True)
        if trim:
            ncol = cl.get_value("ncol", "number of columns to trim from windows", 0)
            nrow = cl.get_value("nrow", "number of rows to trim from windows", 0)
        else:
            ncol, nrow = None, None

        # define the panel grid. first get the labels and maximum dimensions
        ccdinf = spooler.get_ccd_pars(source, resource)

        nxdef = cl.get_default("nx", 3)

        if len(ccdinf) > 1:
            ccd = cl.get_value("ccd", "CCD(s) to plot [0 for all]", "0")
            if ccd == "0":
                ccds = list(ccdinf.keys())
            else:
                ccds = ccd.split()
                check = set(ccdinf.keys())
                if not set(ccds) <= check:
                    raise hcam.HipercamError("At least one invalid CCD label supplied")

            if len(ccds) > 1:
                nxdef = min(len(ccds), nxdef)
                cl.set_default("nx", nxdef)
                nx = cl.get_value("nx", "number of panels in X", 3, 1)
            else:
                nx = 1
        else:
            nx = 1
            ccds = list(ccdinf.keys())

        cl.set_default("pause", 0.0)
        pause = cl.get_value(
            "pause", "time delay to add between" " frame plots [secs]", 0.0, 0.0
        )

        cl.set_default("plotall", False)
        plotall = cl.get_value(
            "plotall", "plot all frames," " regardless of status?", False
        )

        # bias frame (if any)
        bias = cl.get_value(
            "bias",
            "bias frame ['none' to ignore]",
            cline.Fname("bias", hcam.HCAM),
            ignore="none",
        )
        if bias is not None:
            # read the bias frame
            bias = hcam.MCCD.read(bias)
            fprompt = "flat frame ['none' to ignore]"
        else:
            fprompt = "flat frame ['none' is normal choice with no bias]"

        lowlevel = cl.get_value(
            "lowlevel", "bias level lower limit for warnings", 2000.0
        )

        highlevel = cl.get_value(
            "highlevel", "bias level upper limit for warnings", 3500.0
        )

        # flat (if any)
        flat = cl.get_value(
            "flat", fprompt, cline.Fname("flat", hcam.HCAM), ignore="none"
        )
        if flat is not None:
            # read the flat frame
            flat = hcam.MCCD.read(flat)

        # defect file (if any)
        dfct = cl.get_value(
            "defect",
            "defect file ['none' to ignore]",
            cline.Fname("defect", hcam.DFCT),
            ignore="none",
        )
        if dfct is not None:
            # read the defect frame
            dfct = defect.MccdDefect.read(dfct)

        # Get windows from hdriver
        setup = cl.get_value("setup", "display current hdriver window settings", False)

        if setup:
            drurl = cl.get_value(
                "drurl", "URL for driver windows", "http://192.168.1.2:5100"
            )
        else:
            drurl = None


        # define the display intensities
        msub = cl.get_value("msub", "subtract median from each window?", True)

        iset = cl.get_value(
            "iset",
            "set intensity a(utomatically)," " d(irectly) or with p(ercentiles)?",
            "a",
            lvals=["a", "d", "p"],
        )
        iset = iset.lower()

        plo, phi = 5, 95
        ilo, ihi = 0, 1000
        if iset == "d":
            ilo = cl.get_value("ilo", "lower intensity limit", 0.0)
            ihi = cl.get_value("ihi", "upper intensity limit", 1000.0)
        elif iset == "p":
            plo = cl.get_value(
                "plo", "lower intensity limit percentile", 5.0, 0.0, 100.0
            )
            phi = cl.get_value(
                "phi", "upper intensity limit percentile", 95.0, 0.0, 100.0
            )

        # region to plot
        for i, cnam in enumerate(ccds):
            nxtot, nytot, nxpad, nypad = ccdinf[cnam]
            if i == 0:
                xmin, xmax = float(-nxpad), float(nxtot + nxpad + 1)
                ymin, ymax = float(-nypad), float(nytot + nypad + 1)
            else:
                xmin = min(xmin, float(-nxpad))
                xmax = max(xmax, float(nxtot + nxpad + 1))
                ymin = min(ymin, float(-nypad))
                ymax = max(ymax, float(nytot + nypad + 1))

        xlo = cl.get_value("xlo", "left-hand X value", xmin, xmin, xmax)
        xhi = cl.get_value("xhi", "right-hand X value", xmax, xmin, xmax)
        ylo = cl.get_value("ylo", "lower Y value", ymin, ymin, ymax)
        yhi = cl.get_value("yhi", "upper Y value", ymax, ymin, ymax)

        # many parameters for profile fits, although most are not
        # plotted by default
        profit = cl.get_value("profit", "do you want profile fits?", False)

        if profit:
            nxf = cl.get_value("nxf", "maximum number of fit panels in X", 3)
            method = cl.get_value(
                "method", "fit method g(aussian) or m(offat)", "m", lvals=["g", "m"]
            )
            if method == "m":
                beta = cl.get_value(
                    "beta", "initial exponent for Moffat fits", 5.0, 0.5, 20.
                )
            else:
                beta = 0.0
            fwhm_min = cl.get_value(
                "fwhm_min", "minimum FWHM to allow [unbinned pixels]", 1.5, 0.01
            )
            fwhm = cl.get_value(
                "fwhm",
                "initial FWHM [unbinned pixels] for profile fits",
                6.0,
                fwhm_min,
            )
            shbox = cl.get_value(
                "shbox",
                "half width of box for initial location"
                " of target [unbinned pixels]",
                11.0,
                2.0,
            )
            smooth = cl.get_value(
                "smooth",
                "FWHM for smoothing for initial object"
                " detection [binned pixels]",
                6.0,
            )
            fhbox = cl.get_value(
                "fhbox",
                "half width of box for profile fit" " [unbinned pixels]",
                21.0,
                3.0,
            )
            hmin = cl.get_value(
                "hmin", "minimum peak height to accept the fit", 50.0
            )
            read = cl.get_value("read", "readout noise, RMS ADU", 3.0)
            gain = cl.get_value("gain", "gain, ADU/e-", 1.0)
            thresh = cl.get_value("thresh", "number of RMS to reject at", 4.0)

        fwnmax = cl.get_value(
            "fwnmax", "maximum number of frame to buffer FWHM [0 to ignore]", 100, 0
        )

        fwymax = cl.get_value(
            "fwymax", "maximum FWHM value to plot on Y-axis [unbinned pixels]", 10., 2.
        )

        fwwidth = cl.get_value(
            "fwwidth", "FWHM plot width [inches, 0 for default]", 0., 0.
        )

        fwheight = cl.get_value(
            "fwheight", "FWHM plot height [inches, 0 for default]", 0., 0.
        )


    ###############################################################################

    # Phew. We finally have all the inputs and now can now display stuff.

    # track which CCDs have been plotted at least once for the profile fits
    plotted = np.array(len(ccds)*[False])
    not_selected = True
    img_accum = len(ccds)*[None]
    first_image = True
    first_fwhm = True

    # Now onto the animated plots.
    with spooler.data_source(source, resource, first, full=False) as spool:

        nframe, total_time = 0, 0.
        for mccd in spool:

            if server_or_local:
                # Handle the waiting game ...
                give_up, try_again, total_time = spooler.hang_about(
                    mccd, twait, tmax, total_time
                )

                if give_up:
                    print("rtplot stopped")
                    break
                elif try_again:
                    continue

            # Trim the frames: ULTRACAM windowed data has bad columns
            # and rows on the sides of windows closest to the readout
            # which can badly affect reduction. This option strips
            # them.
            if trim:
                hcam.ccd.trim_ultracam(mccd, ncol, nrow)

            # indicate progress
            #            try:
            tstamp = Time(mccd.head["TIMSTAMP"], format="isot", precision=3)
            print(
                "{:d}, utc= {:s} ({:s}), ".format(
                    mccd.head.get("NFRAME",nframe+1),
                    tstamp.iso,
                    "ok" if mccd.head.get("GOODTIME", True) else "nok",
                ),
                end="",
            )
            #            except:
            #   # sometimes times are junk.
            #   print(
            #      '{:d}, utc = {:s}, '.format(
            #           mccd.head['NFRAME'], '2000-01-01 00:00:00.000'), end=''
            #   )

            # accumulate errors
            emessages = []

            # bias level checks
            if lowlevel != 0.0:
                median = mccd.get_num(0).get_num(0).median()
                if median < lowlevel:
                    emessages.append(
                        "** low bias level, median vs limit: {:.1f} vs {:.1f}".format(
                            median, lowlevel
                        )
                    )

            if highlevel != 0.0:
                try:
                    median = mccd.get_num(0).get_num(1).median()
                except:
                    median = mccd.get_num(0).get_num(0).median()

                if median > highlevel:
                    emessages.append(
                        "** high bias level, median vs limit: {:.1f} vs {:.1f}".format(
                            median, lowlevel
                        )
                    )

            if nframe == 0:
                # get the bias and flat into shape first time through

                if bias is not None:
                    # crop the bias on the first frame only
                    bias = bias.crop(mccd)

                if flat is not None:
                    # crop the flat on the first frame only
                    flat = flat.crop(mccd)

            if setup:
                # Get setup windows from hdriver / udriver. Fair bit of
                # error checking needed. 'got_windows' indicates if
                # anything useful found, 'swindows' is a list of
                # (llx,lly,nx,ny) tuples if somthing is found.
                try:
                    r = requests.get(drurl, timeout=0.2)

                    if r.text.strip() == "No valid data available":
                        emessages.append(
                            f"** bad return from hdriver = {r.text.strip()}"
                        )
                        got_windows = False

                    elif r.text.strip() == "fullframe":
                        # to help Stu out a bit, effectively just
                        # ignore this one
                        got_windows = False

                    else:
                        # OK, got something
                        got_windows = True
                        lines = r.text.split("\r\n")
                        xbinh, ybinh, nwinh = lines[0].split()
                        xbinh, ybinh, nwinh = int(xbinh), int(ybinh), int(nwinh)
                        swindows = []
                        for line in lines[1 : nwinh + 1]:
                            llxh, llyh, nxh, nyh = line.split()
                            swindows.append((int(llxh), int(llyh), int(nxh), int(nyh)))

                        if nwinh != len(swindows):
                            emessages.append(
                                f"** expected {nwinh} windows from"
                                " (u/h)driver but got {len(swindows)}"
                            )
                            got_windows = False

                except (
                        requests.exceptions.ConnectionError,
                        socket.timeout,
                        requests.exceptions.Timeout,
                ) as err:
                    emessages.append(" ** hdriver error: {!r}".format(err))
                    got_windows = False

            else:
                got_windows = False

            # wind through the CCDs to display, accumulating stuff
            # to send to the plot manager
            message = ""

            skipped = True
            for nc, cnam in enumerate(ccds):
                ccd = mccd[cnam]

                if plotall or ccd.is_data():
                    # "is_data" indicates genuine data as opposed to junk
                    # that results from nskip > 0.
                    plotted[nc] = True

                    # subtract the bias
                    if bias is not None:
                        ccd -= bias[cnam]

                    # divide out the flat
                    if flat is not None:
                        ccd /= flat[cnam]

                    if msub:
                        # subtract median from each window
                        for wind in ccd.values():
                            wind -= wind.median()

                    # set intensity limits
                    if iset == "p":
                        # Set intensities from percentiles
                        if xlo is not None and xhi is not None:
                            pxlo = min(xlo, xhi)
                            pxhi = max(xlo, xhi)
                        else:
                            pxlo, pxhi = None, None
                        if ylo is not None and yhi is not None:
                            pylo = min(ylo, yhi)
                            pyhi = max(ylo, yhi)
                        else:
                            pylo, pyhi = None, None
                        vmin, vmax = ccd.percentile(
                            (plo, phi), pxlo, pxhi, pylo, pyhi
                        )

                    elif iset == "a":
                        # Set intensities from min/max range
                        vmin, vmax = ccd.min(), ccd.max()

                    elif iset == "d":
                        vmin, vmax = dlo, dhi

                    content = [ccd, vmin, vmax]

                    if got_windows:
                        content.append(swindows)
                    else:
                        content.append(None)

                    if dfct is not None and cnam in dfct:
                        content.append(dfct[cnam])
                    else:
                        content.append(None)

                    # Save the content to send to the plot updater
                    img_accum[nc] = content

                    # accumulate string of image scalings
                    if nc:
                        message += ", ccd {:s}: {:.1f}, {:.1f}, exp: {:.4f}".format(
                            cnam, vmin, vmax, mccd.head["EXPTIME"]
                        )
                    else:
                        message += "ccd {:s}: {:.1f}, {:.1f}, exp: {:.4f}".format(
                            cnam, vmin, vmax, mccd.head["EXPTIME"]
                        )
                    skipped = False

                elif not (profit and not_selected):
                    # If we are in a state of accumulating for profile fit
                    # selection we want each CCD to have something, so
                    # we don't overwrite with None on skipped images
                    # as we normally do
                    img_accum[nc] = None

            # Print messages
            if skipped:
                print(f'{message}skipped')
            else:
                print(f'{message}')
            for emessage in emessages:
                print(emessage)

            # at this point "img_accum" contains a list of lists, each of
            # which consists of:
            #
            # [ccd, vmin, vmax, swindows, dfct]
            #
            # i.e. the CCD, intensity range, setup windows and defects, or
            # "None" if the CCD was skipped due to nskip

            if profit and not_selected and plotted.all():
                # Finally have at least one proper exposure of all CCDs
                # from which stars can be selected.
                not_selected = False

                # Ready to make first plot of all CCDs
                img_fig, img_axs = setup_images(len(ccds), nx, "Profile fit selection", imwidth, imheight)
                for ax, cnam, content in zip(img_axs, ccds, img_accum):
                    disp_ccd(
                        ax, cnam, xlo, xhi, ylo, yhi, cmap, content, False
                    )

                # Cursor selection routine
                cselect = CursorSelect(
                    img_fig, img_axs, ccds, img_accum, shbox, fwhm, beta,
                    method, smooth, fhbox, hmin, fwhm_min, read, gain, thresh
                )

                plt.show()

            if profit and not not_selected:
                # if profile fitting is being carried out, then this
                # section is implemented for each new image

                targets = cselect.targets

                # first update search box positions. In normal operation
                # this moves the boxes to match the target positions previously
                # fitted.
                for targ in targets:
                    targ.update_sbox()

                # now attempt fits
                fit_accum = prof_fit(
                    ccds, targets, img_accum,
                    method, smooth, fhbox, hmin, fwhm_min, read, gain, thresh
                )

            else:
                fit_accum = []

            if not profit or not not_selected:

                # The image animation
                if first_image:
                    # one-off setup
                    first_image = False

                    # Create the image plot manager
                    imanager = ImageManager(
                        ccds, nx, imwidth, imheight, xlo, xhi, ylo, yhi,
                        cmap, img_accum, fit_accum
                    )

                    plt.show(block=False)
                    plt.pause(0.1)

                else:
                    # send updates to image plot manager
                    imanager.update(img_accum, fit_accum)

                if profit and fwnmax > 1:
                    # The fwhm animation
                    if first_fwhm:
                        # one-off setup
                        first_fwhm = False

                        # Create the FWHM plot manager
                        nfrm = mccd.head.get("NFRAME",nframe+1)
                        fwhmmanager = FwhmManager(
                             fit_accum, nfrm, fwnmax, fwymax, fwwidth, fwheight
                        )

                        plt.show(block=False)
                        plt.pause(0.1)

                    else:
                        # send updates to fwhm plot manager
                        fwhmmanager.update(fit_accum)

            if not (profit and not_selected) and pause > 0.0:
                # pause between frames
                time.sleep(pause)

            # update the frame number
            nframe += 1

    # At then end the plots will close automatically,
    # so block this by asking the user to confirm
    reply = input('\nHit carriage return to close the plot(s): ')

# From here is support code not visible outside

def setup_images(nccd, nx, title, width, height):
    """
    Sets up the figure and axes for the images display.

    Arguments::

       nccd : int
          number of CCDs to display

       nx : int
          number of panels in the X direction.

       title : str
          title of figure

       width : float
          width, inches

       height : float
          height, inches

    Returns (fig, axs)

    The Figure and Axes, one per CCD
    """

    # Create the figure for the image plot
    if width > 0 and height > 0:
        fig = plt.figure(title, figsize=(width,height))
    else:
        fig = plt.figure(title)

    # Define config of images
    ny = nccd // nx if nccd % nx == 0 else nccd // nx + 1

    # Create the axes
    for ind in range(nccd):
        if ind == 0:
            ax0 = fig.add_subplot(ny,nx,ind+1)
            axs = [ax0]
        else:
            axs.append(fig.add_subplot(ny,nx,ind+1,sharex=ax0,sharey=ax0))
    return (fig, axs)


class ImageManager:
    """Class to control the image animation

    Basic idea is that initialising it stores all the very many inputs
    as attributes and creates the plot returning structures containing
    animated artists which get updated per frame. Allows re-scaling of
    intensity levels of the images, plotting of defects and setup
    windows and also the search box and fitted positions of any
    profile fit targets.

    """

    def __init__(
            self, cnams, nx, width, height, xlo, xhi, ylo, yhi, cmap, img_accum, fit_accum
    ):
        """
        Initialises the plot. Arguments:

          cnams : list of strings
             CCD names to plot

          nx : int
             max number of panels in X

          width : float
             plot width [inches]

          height : float
             plot height [inches]

          xlo : float
             left-hand limit of region to determine percentiles and for display

          xhi : float
             right-hand limit of region to display

          ylo : float
             lower limit of region to display

          yhi : float
             upper limit of region to display

          cmap : str  | None
             Matplotlib colour map. None gives default


          img_accum : list of lists
             one list per CCD being displayed. Contains the information
             required for the image plot. Per CCD the list should be:
             [ccd, vmin, vmax, swindows, dfcts] or None if the CCD is
             being skipped. swindows -- setup windows -- can be None.
             dfcts -- defects -- can also be None.

          fit_accum : list of tuples
             one tuple per target being profile fitted, containg all
             info needed to make plots of the fit etc. This can be None
             if no fit was made. See Fpar.fit for what the tuples contain.
        """

        # basic check
        assert(len(img_accum) == len(cnams))

        # create figure and axes
        self.fig, self.axs = setup_images(len(cnams), nx, "CCD display", width, height)
        self.cnv = self.fig.canvas
        self._bg = None

        # rtplot inputs
        self.cnams = cnams
        self.xlo = xlo
        self.xhi = xhi
        self.ylo = ylo
        self.yhi = yhi
        self.cmap = cmap

        # list of dictionaries of artists for each image panel
        self.img_artists = []

        # now we actually create the artists
        for ax, cnam, content in zip(self.axs, self.cnams, img_accum):
            if content is None:
                # do nothing much other than add a placeholder
                self.img_artists.append(None)
            else:
                # plot the CCD, return with the animated artists
                self.img_artists.append(
                    self._disp_ccd(ax, cnam, content)
                )

        # now for the fit targets
        self.targ_artists = self._disp_targs(fit_accum)

        # grab the background on every draw
        self.cid = self.cnv.mpl_connect("draw_event", self.on_draw)

    def on_draw(self, event):
        """Callback to register with 'draw_event'."""
        cnv = self.cnv
        if event is not None and event.canvas != cnv:
            raise RuntimeError
        self._bg = cnv.copy_from_bbox(cnv.figure.bbox)
        self._draw_animated()

    def _draw_animated(self):
        """Draws all of the animated artists for the image plot self.artists
        is a list of dictionaries of lists ...

        """

        for dartist in self.img_artists:
            if dartist is not None:
                for lartist in dartist.values():
                    for artist in lartist:
                        if artist is not None:
                            self.fig.draw_artist(artist)

        for artist in self.targ_artists:
            if artist is not None:
                self.fig.draw_artist(artist)

    def update(self, img_accum, fit_accum):
        """Updating routine, Passed arguments containg enough information
        to update the image plots and also any fitted stars. The real
        work is passed down to _disp_ccd and _disp_targs

        """
        # now update / create the artists

        # first the images
        lartists = []
        for ax, cnam, content, artists in zip(self.axs, self.cnams, img_accum, self.img_artists):
            if content is None:
                # just pass old artists through
                lartists.append(artists)
            else:
                # plot the CCD, return with the updated animated artists
                lartists.append(self._disp_ccd(ax, cnam, content, artists))
        self.img_artists = lartists

        # then the profile fit targets
        self.targ_artists = self._disp_targs(fit_accum, self.targ_artists)

        cnv = self.cnv
        fig = self.fig
        if self._bg is None:
            self.on_draw(None)
        else:
            # restore the background
            cnv.restore_region(self._bg)
            self._draw_animated()
            cnv.blit(fig.bbox)
        cnv.flush_events()

    def _disp_ccd(self, ax, cnam, content, artists=None):
        """Displays a CCD ccd, name cnam, in Axes ax.

        If "artists" is None, a dictionary will be created and
        returned containing various lists of animated artists.
        Otherwise it is assumed to be such a list resulting from an
        earlier run and will be updated.

        """

        if artists is None:

            # in this case we are setting up for the first time
            artists = disp_ccd(
                ax, cnam,
                self.xlo, self.xhi, self.ylo, self.yhi, self.cmap,
                content, True
            )

            # need to re-draw to avoid irritating distorted image
            self.cnv.draw()

        else:

            # unpack the new content
            ccd, vmin, vmax, swindows, dfct = content

            # this is the "usual" post-setup case where we just update
            # the artists

            # the CCD window data
            for wind, img in zip(ccd.values(), artists['windows']):
                img.set_data(wind.data)
                img.set_clim(vmin, vmax)

            # defects don't change so nothing done to them.

            # the setup windows. Can change in number as well as size
            # so delete old ones (if there are any) and re-create each
            # time remove old setup windows
            swins = artists['swindows']
            for artist in swins:
                artist.remove()
            artists['swindows'] = []

            if swindows is not None:

                # draw new ones, keeping refs to objects for next time
                swins = []
                for llxh, llyh, nxh, nyh in swindows:
                    box, = ax.plot(
                        [llxh-0.5, llxh+nxh-0.5, llxh+nxh-0.5, llxh-0.5, llxh-0.5],
                        [llyh-0.5, llyh-0.5, llyh+nyh-0.5, llyh+nxh-0.5, llyh-0.5],
                        '--', color=COL_SETUP, animated=True
                    )
                    swins.append(box)
                artists['swindows'] = swins

        return artists

    def _disp_targs(self, fit_accum, artists=None):
        """Displays target as (a) a search box and (b) a circle of radius
        equal to the FWHM and a dot for the target.

        If "artists" is None, a list will be created and
        returned containing the animated artists.
        Otherwise it is assumed to be such a list resulting from an
        earlier run and will be updated.

        """

        if fit_accum is None:
            return None

        if artists is None:

            # mapping from CCD name to axes
            ccd2axes = dict(zip(self.cnams,self.axs))

            artists = []
            for ntarg, content in enumerate(fit_accum):
                if content is not None:
                    fpar = content[0]
                    ax = ccd2axes[fpar.cnam]
                    artists += fpar.plot(ax, True)
                else:
                    artists += [None,None,None]

            # re-draw
            self.cnv.draw()

        else:

            for ntarg, content in enumerate(fit_accum):
                if content is not None:
                    fpar = content[0]
                    if artists[3*ntarg] is None:
                        # The artists have yet to be made
                        ax = ccd2axes[fpar.cnam]
                        artists[3*ntarg:3*ntarg+3] = fpar.plot(ax, True)
                    else:
                        # they exist already and need updating
                        dot,circ,sbox = artists[3*ntarg:3*ntarg+3]
                        dot.set_data(fpar.x,fpar.y)
                        circ.set_center((fpar.x,fpar.y))
                        circ.set_radius(fpar.fwhm)
                        xlo, xhi, ylo, yhi = fpar.region()
                        sbox.set_data(
                            [xlo,xhi,xhi,xlo,xlo],[ylo,ylo,yhi,yhi,ylo]
                        )

        return artists


def disp_ccd(ax, cnam, xlo, xhi, ylo, yhi, cmap, content, animated):
    """Displays a CCD ccd, name cnam, in Axes ax.

    If used for movie-style display, set animated=True
    In this case a dictionary of animated artists will be returned
    """

    # unpack the new content
    ccd, vmin, vmax, swindows, dfct = content

    if animated:
        artists = {}
        wins = artists['windows'] = []

    for wnam, wind in ccd.items():
        left, right, bottom, top = wind.extent()

        # Display the image of each window
        img = ax.imshow(
            wind.data,
            extent=(left, right, bottom, top),
            aspect="equal",
            origin="lower",
            cmap=cmap,
            interpolation="nearest",
            vmin=vmin,
            vmax=vmax,
            animated=animated
        )
        if animated:
            wins.append(img)

        # Plot boundary on window (fixed)
        ax.plot(
            [left, right, right, left, left],
            [bottom, bottom, top, top, bottom],
            color=Params["win.box.col"],
        )

        # Label them (fixed)
        ax.text(
            left - 3,
            bottom - 3,
            wnam,
            fontsize=Params["win.label.fs"],
            color=Params["win.label.col"],
            ha="right",
            va="top",
            clip_on=True,
        )

        # plot defects
        if dfct is None:
            dfcts = []
        else:
            dfcts = hcam.mpl.pCcdDefect(ax, dfct, True).values()
        if animated:
            artists['defects'] = dfcts

        # plot setup windows
        if swindows is None:
            swins = []
        else:
            swins = []
            for llxh, llyh, nxh, nyh in swindows:
                box, = ax.plot(
                    [llxh-0.5, llxh+nxh-0.5, llxh+nxh-0.5, llxh-0.5, llxh-0.5],
                    [llyh-0.5, llyh-0.5, llyh+nyh-0.5, llyh+nxh-0.5, llyh-0.5],
                    '--', color=COL_SETUP, animated=True
                )
                swins.append(box)

        if animated:
            artists['swindows'] = swins

        # Plot outermost border of CCD (fixed)
        ax.plot(
            [0.5, ccd.nxtot + 0.5, ccd.nxtot + 0.5, 0.5, 0.5],
            [0.5, 0.5, ccd.nytot + 0.5, ccd.nytot + 0.5, 0.5],
            color=Params["ccd.box.col"],
        )

        # Set title and axis labels (fixed)
        ax.set_title(
            f'CCD {cnam}',
            color=Params["axis.label.col"], fontsize=Params["axis.label.fs"]
        )

        # set axis limits
        ax.set_xlim(xlo, xhi)
        ax.set_ylim(ylo, yhi)
        ax.set_aspect('equal')
        for tick in ax.get_yticklabels():
            tick.set_rotation(90)

    if animated:
        return artists

class FwhmManager:
    """Class to start and control the FWHM history animation
    """

    def __init__(
            self, accum, nframe, mxframes, fwmax, width, height
    ):
        """
        Initialises the FWHM history plot. Arguments:

          accum : list of tuples
             one tuple per target being profile fitted, containing all
             info needed to make plots of the fit etc. This can be None
             if no fit was made. See Fpar.fit for what the tuples contain.

          nframe : int
             initial frame number

          mxframes : int
             maximum number of frame results to retain in buffers

          fwmax : float
             maximum height for FWHM plot in pixels

          width : float
             plot width [inches]

          height : float
             plot height [inches]

        """

        # Create the figure
        if width > 0 and height > 0:
            self.fig = plt.figure("FWHM vs frame number", figsize=(width,height))
        else:
            self.fig = plt.figure("FWHM vs frame number")

        self.cnv = self.fig.canvas
        self.ax = self.fig.add_subplot(animated=True)
        self._bg = None

        # rtplot inputs
        self.nframe = nframe
        self.mxframes = mxframes
        self.fwmax = fwmax

        # derived
        self.xlo = nframe - 1
        self.xhi = nframe + mxframes
        self.ylo = 0
        self.yhi = fwmax

        self.ax.set_xlim(self.xlo,self.xhi)
        self.ax.set_ylim(self.ylo,self.yhi)
        self.ax.set_xlabel('Frame number')
        self.ax.set_ylabel('FWHM [unbinned pixels]')

        # buffers for the FWHM vs nframe data and a list of artists
        # for each FWHM plot
        self.fwhm_buffers = []
        self.fwhm_artists = []

        # now we actually create / plot the artists
        for ntarg, content in enumerate(accum):
            if content is None:
                # placeholders
                self.fwhm_buffers.append(None)
                self.fwhm_artists.append(None)
            else:
                fpar = content[0]
                xs = [nframe]
                ys = [fpar.fwhm]

                # store first point
                self.fwhm_buffers.append((xs,ys))

                # plot the FWHM vs frame number
                fwhm, = self.ax.plot(xs,ys,animated=True,label=f'{ntarg+1}')
                self.fwhm_artists.append(fwhm)
        self.ax.legend()
#        self.cnv.draw()

        # grab the background on every draw
        self.cid = self.cnv.mpl_connect("draw_event", self.on_draw)

    def on_draw(self, event):
        """Callback to register with 'draw_event'."""
        cnv = self.cnv
        if event is not None and event.canvas != cnv:
            raise RuntimeError
        self._bg = cnv.copy_from_bbox(cnv.figure.bbox)
        self._draw_animated()

    def _draw_animated(self):
        # draw all of the animated artists. NB draw
        # Axes before the lines if you want to see anything!
        self.fig.draw_artist(self.ax)

        for artist in self.fwhm_artists:
            if artist is not None:
                self.fig.draw_artist(artist)



    def update(self, accum):
        """updating routine, Pass it accum which contains a list of outputs
        from Fpar.fit run on each target.

        """

        # track the frame number
        self.nframe += 1

        # now we actually create / update the artists
        for ntarg in range(len(accum)):
            if accum[ntarg] is not None:
                fpar = accum[ntarg][0]
                if self.fwhm_artists[ntarg] is None:
                    xs = [nframe,]
                    ys = [fpar.fwhm,]
                    fwhm, = self.ax.plot(xs,ys,animated=True)
                    self.fwhm_artists[ntarg] = fwhm
                else:
                    # get data
                    xs,ys = self.fwhm_buffers[ntarg]

                    # strip out stuff at the start (should just be one frame,
                    # but better be safe than sorry)
                    for n, x in enumerate(xs):
                        if x > self.nframe - self.mxframes:
                            xs, ys = xs[n:], ys[n:]
                            break
                    else:
                        xs, ys = [], []

                    # tack on new value, update artist
                    xs.append(self.nframe)
                    ys.append(fpar.fwhm)
                    self.fwhm_artists[ntarg].set_data(xs,ys)

                # save current data to buffers
                self.fwhm_buffers[ntarg] = (xs,ys)

        if self.nframe > self.xhi - 1:
            # update axes limits
            xadd = self.nframe - self.xhi + 1
            self.xlo += xadd
            self.xhi += xadd
            self.ax.set_xlim(self.xlo,self.xhi)

        cnv = self.cnv
        fig = self.fig
        if self._bg is None:
            self.on_draw(None)
        else:
            # restore the background
            cnv.restore_region(self._bg)
            self._draw_animated()
            cnv.blit(fig.bbox)
        cnv.flush_events()

class CursorSelect():
    """
    Avoids spurious panning clicks from being registered
    """

    def __init__(self,
                 fig, axs, ccds, img_accum, shbox, fwhm, beta, method,
                 smooth, fhbox, hmin, fwhm_min, read, gain, thresh
                 ):
        """
        fig : the Figure
        axs : the Axes, one per CCD
        img_accum : image content data
        shbox : falf width search box
        """

        self.cnv = fig.canvas
        self.axs = axs
        self.ccds = ccds
        self.img_accum = img_accum
        self.shbox = shbox
        self.fwhm = fwhm
        self.beta = beta
        self.method = method
        self.smooth = smooth
        self.fhbox = fhbox
        self.hmin = hmin
        self.fwhm_min = fwhm_min
        self.read = read
        self.gain = gain
        self.thresh = thresh

        self.press = False
        self.move = False
        self.c1=self.cnv.mpl_connect('button_press_event', self._onpress)
        self.c2=self.cnv.mpl_connect('button_release_event', self._onrelease)
        self.c3=self.cnv.mpl_connect('motion_notify_event', self._onmove)

        print('\nClick to select stars; q to exit and start animation')
        self.targets = []
        self.ntarg = 0

    def _onclick(self, event):
        """
        Where stuff is done
        """

        if event.inaxes is not None:
            for ax, cnam, content in zip(self.axs,self.ccds,self.img_accum):

                if event.inaxes == ax:

                    # clicked inside an Axes
                    x, y = event.xdata, event.ydata

                    # extract the CCD
                    ccd = content[0]

                    # check that the position is inside a window
                    wnam = ccd.inside(x, y, 2)

                    if wnam is not None:
                        # store the position, Window label, target number,
                        # box size fwhm, beta
                        fpar = Fpar(cnam, wnam, x, y, self.shbox, self.fwhm, self.beta)
                        results, message = fpar.fit(
                            ccd, self.method, self.smooth, self.fhbox,
                            self.hmin, self.fwhm_min, self.read, self.gain, self.thresh
                        )
                        if results is not None:
                            # fitted OK
                            self.ntarg += 1
                            self.targets.append(fpar)
                            print(
                                f'\n   target {self.ntarg} added at initial x,y = '
                                f'{x:.2f}, {y:.2f} in CCD {cnam}, window {wnam}, refined by fit with results:'
                            )
                            print(f'   {message}')
                            fpar.plot(ax)
                            self.cnv.draw()
                        else:
                            print(f'\n   ** fit failed for position x,y = {x:.2f}, {y:.2f} in CCD {cnam}, window {wnam}; no new target added')
                            print(f'   ** fit message = {message}')

    def _onpress(self,event):
        self.press = True

    def _onmove(self,event):
        if self.press:
            self.move = True

    def _onrelease(self,event):
        # only call onclick in special circumstances
        if self.press and not self.move:
            self._onclick(event)
        self.press = False
        self.move = False

class Fpar:

    """Class for representing a target for profile fits. Stores
    the CCD name and window name where it is located."""

    def __init__(self, cnam, wnam, x, y, shbox, fwhm, beta):
        """
        x,y used as initial target position and initial centre of search box
        """
        self.cnam = cnam
        self.wnam = wnam
        self.shbox = shbox
        self.x_cbox = self.x = x
        self.y_cbox = self.y = y
        self.fwhm = fwhm
        self.beta = beta

    def region(self):
        """
        Returns current search region
        """
        return (
            self.x_cbox - self.shbox,
            self.x_cbox + self.shbox,
            self.y_cbox - self.shbox,
            self.y_cbox + self.shbox,
        )

    def plot(self, ax, animated=False):
        """Plots the Fpar as a search box plus and a circle of radius FWHM and
        a dot for target. Returns with a list of three artists. The
        artists can be animated if they are be updated.
        """

        xlo, xhi, ylo, yhi = self.region()

        sbox, = ax.plot(
            [xlo,xhi,xhi,xlo,xlo],[ylo,ylo,yhi,yhi,ylo],
            color='b',animated=animated
        )
        circ = Circle(
            (self.x, self.y), self.fwhm, fill=False,
            color='g', animated=animated
        )
        ax.add_patch(circ)
        dot, = ax.plot(
            self.x, self.y, '.g', animated=animated
        )
        return (dot,circ,sbox)

    def fit(self, ccd, method, smooth, fhbox, hmin, fwhm_min, read, gain, thresh):
        """Carries out a fit when passed a CCD. If successful,
        x, y, fwhm and beta will be altered but the centre
        of the search region will be unchanged.

        Returns (results, message) where results = (self, fradii, fdata, fok, vmin, vmax, r, f)
        if successful, None if not. "message" is a string summarising the result.

        """

        try:
            # extract search box data from the CCD.
            xlo, xhi, ylo, yhi = self.region()
            swind = ccd[self.wnam].window(xlo, xhi, ylo, yhi)

            # carry out initial search
            x, y, peak = swind.search(smooth, self.x, self.y, hmin, False)

            # now for a more refined fit. First extract region centred
            # on new position
            fwind = ccd[self.wnam].window(
                x - fhbox, x + fhbox, y - fhbox, y + fhbox
            )

            # crude estimate of sky background
            sky = np.percentile(fwind.data, 50)

            # refine the Aperture position by fitting the profile
            (
                (sky, height, x, y, fwhm, beta),
                epars,
                (wfit, X, Y, sigma, chisq, nok, nrej, npar, nfev, message),
            ) = hcam.fitting.combFit(
                fwind,
                method,
                sky,
                peak - sky,
                x,
                y,
                self.fwhm,
                fwhm_min,
                False,
                self.beta,
                20.,
                False,
                read,
                gain,
                thresh,
            )

            if peak > hmin and ccd[self.wnam].distance(x, y) > 1:
                # update some initial parameters for next time
                if method == "g":
                    self.x, self.y, self.fwhm = x, y, fwhm
                elif method == "m":
                    self.x, self.y, self.fwhm, self.beta = x, y, fwhm, beta

                # values vs radial distance, plot range
                ok = sigma > 0
                R = np.sqrt((X - x) ** 2 + (Y - y) ** 2)
                vmin = min(sky, sky + height, fwind.min())
                vmax = max(sky, sky + height, fwind.max())
                extent = vmax - vmin
                vmin -= 0.05*extent
                vmax += 0.05*extent

                # line fit
                r = np.linspace(0, R.max(), 400)
                if method == "g":
                    alpha = 4 * np.log(2.0) / fwhm ** 2
                    f = sky + height * np.exp(-alpha * r ** 2)
                elif method == "m":
                    alpha = 4 * (2 ** (1 / beta) - 1) / fwhm ** 2
                    f = sky + height / (1 + alpha * r ** 2) ** beta

                # save the Fpar, radii, data, flags, plot range, fit x & y
                results = (self, R.flat, fwind.data.flat, ok.flat, vmin, vmax, r, f)

            else:
                results = None
                message += "\n*** below detection threshold. Parameters unchanged."

        except hcam.HipercamError as err:
            results = None
            message = f"fit failed: {err}"

        return (results, message)

    def update_sbox(self):
        """Moves centre of box to match target position"""
        self.x_cbox = self.x
        self.y_cbox = self.y

def prof_fit(ccds, targets, img_accum, method, smooth, fhbox, hmin, fwhm_min, read, gain, thresh):
    """Carries out profile fitting over all targets. Returns container of
    results suitable for potential plotting.

    """

    # first a mapping from CCD name to the image content
    img_map = dict(zip(ccds, img_accum))

    # container for results
    fit_accum = len(targets)*[None]

    for ntarg, fpar in enumerate(targets):
        # carry out fits. Nothing happens if the CCD has not been
        # updated [content = None]
        content = img_map[fpar.cnam]
        if content is not None:
            ccd = content[0]
            results, message = fpar.fit(ccd, method, smooth, fhbox, hmin, fwhm_min, read, gain, thresh)
            print(f' target {ntarg+1}, {message}')
            fit_accum[ntarg] = results

    return fit_accum
