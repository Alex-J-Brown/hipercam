import sys
import os
import time

import numpy as np

import matplotlib.pylab as plt

from astropy.time import Time

import hipercam as hcam
from hipercam import cline, utils, spooler, defect
from hipercam.cline import Cline
from hipercam.mpl import Params

import requests
import socket

# colour for setup windows. works for me at least
# but may need input from Stu
COL_SETUP = (0.8, 0., 0.)

__all__ = [
    "nrtplot",
]

######################################
#
# nrtplot -- display of multiple images
#
######################################


def nrtplot(args=None):
    """``nrtplot [source] (run first [twait tmax] | flist) trim ([ncol
    nrow]) (ccd (nx)) [pause plotall] bias [lowlevel highlevel] flat
    defect setup [drurl] [colour] msub iset (ilo ihi | plo phi) xlo
    xhi ylo yhi profit [method beta fwhm fwhm_min shbox smooth splot
    fhbox hmin read gain thresh]``

    This is 'nrtplot' "new" rtplot, a matplotlib-based replacement for
    the current PGPLOT one. Under development.

    Plots a sequence of images as a movie in near 'real time', hence
    'rt'. Designed to be used to look at images coming in while at the
    telescope, 'rtplot' comes with many options, a large number of
    which are hidden by default, and many of which are only prompted
    if other arguments are set correctly. If you want to see them all,
    invoke as 'rtplot prompt'.  This is worth doing once to know
    rtplot's capabilities.

    rtplot can source data from both the ULTRACAM and HiPERCAM
    servers, from local 'raw' ULTRACAM and HiPERCAM files (i.e. .xml +
    .dat for ULTRACAM, 3D FITS files for HiPERCAM) and from lists of
    HiPERCAM '.hcm' files.

    rtplot optionally allows the selection of targets to be fitted
    with gaussian or moffat profiles, and, if successful, will plot
    circles of 2x the measured FWHM in green over the selected
    targets. This option only works if a single CCD is being plotted.

    Parameters:

        source : string [hidden]
           Data source, five options:

             |  'hs' : HiPERCAM server
             |  'hl' : local HiPERCAM FITS file
             |  'us' : ULTRACAM server
             |  'ul' : local ULTRACAM .xml/.dat files
             |  'hf' : list of HiPERCAM hcm FITS-format files

           'hf' is used to look at sets of frames generated by 'grab' or
           converted from foreign data formats. The standard start-off
           default for ``source'' can be set using the environment variable
           HIPERCAM_DEFAULT_SOURCE. e.g. in bash :code:`export HIPERCAM_DEFAULT_SOURCE="us"`
           would ensure it always started with the ULTRACAM server by default. If
           unspecified, it defaults to 'hl'.

        run : string [if source ends 's' or 'l']
           run number to access, e.g. 'run034'

        flist : string [if source ends 'f']
           name of file list

        first : int [if source ends 's' or 'l']
           exposure number to start from. 1 = first frame; set = 0 to always
           try to get the most recent frame (if it has changed).  For data
           from the |hiper| server, a negative number tries to get a frame not
           quite at the end.  i.e. -10 will try to get 10 from the last
           frame. This is mainly to sidestep a difficult bug with the
           acquisition system.

        twait : float [if source ends 's' or 'l'; hidden]
           time to wait between attempts to find a new exposure, seconds.

        tmax : float [if source ends 's' or 'l'; hidden]
           maximum time to wait between attempts to find a new exposure,
           seconds.

        trim : bool [if source starts with 'u']
           True to trim columns and/or rows off the edges of windows nearest
           the readout which can sometimes contain bad data.

        ncol : int [if trim, hidden]
           Number of columns to remove (on left of left-hand window, and right
           of right-hand windows)

        nrow : int [if trim, hidden]
           Number of rows to remove (bottom of windows)

        ccd : str
           CCD(s) to plot, '0' for all, '1 3' to plot '1' and '3' only, etc.

        nx : int [if more than 1 CCD]
           number of panels across to display.

        pause : float [hidden]
           seconds to pause between frames (defaults to 0). This is in addition
           to any time taken per frame to read and display it, so is just to slow
           things not to set an exact rate.

        plotall : bool [hidden]
           plot all frames regardless of status (i.e. including blank frames
           when nskips are enabled (defaults to False). The profile fitting
           will still be disabled for bad frames.

        bias : str
           Name of bias frame to subtract, 'none' to ignore.

        lowlevel : float [hidden]
           Level below which a warning about low bias levels is warned. Set=0
           to ignore. Applied to first window of first CCD. 2000 about
           right for ULTRACAM.

        highlevel : float [hidden]
           Level above which a warning about high bias levels is warned. Set=0
           to ignore. Applied to first window of first CCD. 3500 about
           right for ULTRACAM.

        flat : str
           Name of flat field to divide by, 'none' to ignore. Should normally
           only be used in conjunction with a bias, although it does allow you
           to specify a flat even if you haven't specified a bias.

        defect : str
           Name of defect file, 'none' to ignore.

        setup : bool
           True/yes to access the current windows from hdriver. Useful
           during observing when setting up windows, but not normally
           otherwise. Next argument (hidden) is the URL to get to
           hdriver. Once setup, you should probably turn this off to
           avoid overloading hdriver, especially if in drift mode as
           it makes a request for the windows for every frame.

        drurl : str [if setup; hidden]
           URL needed to access window setting from the camera
           driver (ultracam, ultraspec, hipercam). The internal server
           in the camera driver must be switched on which can be done
           from the GUI.

        cmap : str [hidden]
           The matplotlib colour map to use. "Greys" gives the usual greyscale.
           "none" will give whatever the current default is. Many other choices:
           "viridis", "jet", "hot", "Oranges" ... Enter and invalid one and
           the program will fail returning a huge list of possibles.

        msub : bool
           subtract the median from each window before scaling for the
           image display or not. This happens after any bias subtraction.

        iset : str [single character]
           determines how the intensities are determined. There are three
           options: 'a' for automatic simply scales from the minimum to the
           maximum value found on a per CCD basis. 'd' for direct just takes
           two numbers from the user. 'p' for percentile dtermines levels
           based upon percentiles determined from the entire CCD on a per CCD
           basis.

        ilo : float [if iset='d']
           lower intensity level

        ihi : float [if iset='d']
           upper intensity level

        plo : float [if iset='p']
           lower percentile level

        phi : float [if iset='p']
           upper percentile level

        xlo : float
           left-hand X-limit for plot, initially at least since it is
           possible to re-size. For iset='p' these limits also set the
           region of the frame over which the percentil will be
           calculated. You will usually want yhi-ylo ~ xhi-xlo in
           magnitude because the aspect ratio is preserved.

        xhi : float
           right-hand X-limit for plot (can be < xlo to invert the display)

        ylo : float
           lower Y-limit for plot

        yhi : float
           upper Y-limit for plot (can be < ylo)

        profit : bool
           carry out profile fits or not. If you say yes, then you
           will get the option of selecting objects with a cursor. The
           program will then attempt to track these from frame to
           frame, and fit their profile. You may need to adjust
           'first' to see anything.  The parameters used for profile
           fits are hidden and you may want to invoke the command with
           'prompt' the first time you try profile fitting.

        nxf : int
           each fit will be displayed in its own panel in a separate
           window from the images. This is the maximum number of such panels
           to use in the X-direction.

        method : str [if profit; hidden]
           this defines the profile fitting method, either a gaussian or a
           moffat profile. The latter is usually best.

        beta : float [if profit and method == 'm'; hidden]
           default Moffat exponent

        fwhm : float [if profit; hidden]
           default FWHM, unbinned pixels.

        fwhm_min : float [if profit; hidden]
           minimum FWHM to allow, unbinned pixels.

        shbox : float [if profit; hidden]
           half width of box for searching for a star, unbinned pixels. The
           brightest target in a region +/- shbox around an intial position
           will be found. 'shbox' should be large enough to allow for likely
           changes in position from frame to frame, but try to keep it as
           small as you can to avoid jumping to different targets and to
           reduce the chances of interference by cosmic rays.

        smooth : float [if profit; hidden]
           FWHM for gaussian smoothing, binned pixels. The initial position
           for fitting is determined by finding the maximum flux in a smoothed
           version of the image in a box of width +/- shbox around the starter
           position. Typically should be comparable to the stellar width. Its
           main purpose is to combat cosmi rays which tend only to occupy a
           single pixel.

        splot : bool [if profit; hidden]
           Controls whether an outline of the search box and a target number
           is plotted (in red) or not.

        fhbox : float [if profit; hidden]
           half width of box for profile fit, unbinned pixels. The fit box is
           centred on the position located by the initial search. It should
           normally be > ~2x the expected FWHM.

        hmin : float [if profit; hidden]
           height threshold to accept a fit. If the height is below this
           value, the position will not be updated. This is to help in cloudy
           conditions.

        read : float [if profit; hidden]
           readout noise, RMS ADU, for assigning uncertainties

        gain : float [if profit; hidden]
           gain, ADU/count, for assigning uncertainties

        thresh : float [if profit; hidden]
           sigma rejection threshold for fits

    """

    command, args = utils.script_args(args)

    # get the inputs
    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:

        # register parameters
        cl.register("source", Cline.GLOBAL, Cline.HIDE)
        cl.register("run", Cline.GLOBAL, Cline.PROMPT)
        cl.register("first", Cline.LOCAL, Cline.PROMPT)
        cl.register("trim", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ncol", Cline.GLOBAL, Cline.HIDE)
        cl.register("nrow", Cline.GLOBAL, Cline.HIDE)
        cl.register("twait", Cline.LOCAL, Cline.HIDE)
        cl.register("tmax", Cline.LOCAL, Cline.HIDE)
        cl.register("flist", Cline.LOCAL, Cline.PROMPT)
        cl.register("ccd", Cline.LOCAL, Cline.PROMPT)
        cl.register("nx", Cline.LOCAL, Cline.PROMPT)
        cl.register("pause", Cline.LOCAL, Cline.HIDE)
        cl.register("plotall", Cline.LOCAL, Cline.HIDE)
        cl.register("bias", Cline.GLOBAL, Cline.PROMPT)
        cl.register("lowlevel", Cline.GLOBAL, Cline.HIDE)
        cl.register("highlevel", Cline.GLOBAL, Cline.HIDE)
        cl.register("flat", Cline.GLOBAL, Cline.PROMPT)
        cl.register("defect", Cline.GLOBAL, Cline.PROMPT)
        cl.register("setup", Cline.GLOBAL, Cline.PROMPT)
        cl.register("drurl", Cline.GLOBAL, Cline.HIDE)
        cl.register("cmap", Cline.GLOBAL, Cline.HIDE)
        cl.register("msub", Cline.GLOBAL, Cline.PROMPT)
        cl.register("iset", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ilo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ihi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("plo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("phi", Cline.LOCAL, Cline.PROMPT)
        cl.register("xlo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("xhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ylo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("yhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("profit", Cline.LOCAL, Cline.PROMPT)
        cl.register("nxf", Cline.LOCAL, Cline.HIDE)
        cl.register("method", Cline.LOCAL, Cline.HIDE)
        cl.register("beta", Cline.LOCAL, Cline.HIDE)
        cl.register("fwhm", Cline.LOCAL, Cline.HIDE)
        cl.register("fwhm_min", Cline.LOCAL, Cline.HIDE)
        cl.register("shbox", Cline.LOCAL, Cline.HIDE)
        cl.register("smooth", Cline.LOCAL, Cline.HIDE)
        cl.register("splot", Cline.LOCAL, Cline.HIDE)
        cl.register("fhbox", Cline.LOCAL, Cline.HIDE)
        cl.register("hmin", Cline.LOCAL, Cline.HIDE)
        cl.register("read", Cline.LOCAL, Cline.HIDE)
        cl.register("gain", Cline.LOCAL, Cline.HIDE)
        cl.register("thresh", Cline.LOCAL, Cline.HIDE)

        # get inputs
        default_source = os.environ.get('HIPERCAM_DEFAULT_SOURCE','hl')
        source = cl.get_value(
            "source",
            "data source [hs, hl, us, ul, hf]",
            default_source,
            lvals=("hs", "hl", "us", "ul", "hf"),
        )

        # set some flags
        server_or_local = source.endswith("s") or source.endswith("l")

        if server_or_local:
            resource = cl.get_value("run", "run name", "run005")
            if source == "hs":
                first = cl.get_value("first", "first frame to plot", 1)
            else:
                first = cl.get_value("first", "first frame to plot", 1, 0)

            twait = cl.get_value(
                "twait", "time to wait for a new frame [secs]", 1.0, 0.0
            )
            tmax = cl.get_value(
                "tmax", "maximum time to wait for a new frame [secs]", 10.0, 0.0
            )

        else:
            resource = cl.get_value(
                "flist", "file list", cline.Fname("files.lis", hcam.LIST)
            )
            first = 1

        trim = cl.get_value("trim", "do you want to trim edges of windows?", True)
        if trim:
            ncol = cl.get_value("ncol", "number of columns to trim from windows", 0)
            nrow = cl.get_value("nrow", "number of rows to trim from windows", 0)
        else:
            ncol, nrow = None, None

        # define the panel grid. first get the labels and maximum dimensions
        ccdinf = spooler.get_ccd_pars(source, resource)

        nxdef = cl.get_default("nx", 3)

        if len(ccdinf) > 1:
            ccd = cl.get_value("ccd", "CCD(s) to plot [0 for all]", "0")
            if ccd == "0":
                ccds = list(ccdinf.keys())
            else:
                ccds = ccd.split()
                check = set(ccdinf.keys())
                if not set(ccds) <= check:
                    raise hcam.HipercamError("At least one invalid CCD label supplied")

            if len(ccds) > 1:
                nxdef = min(len(ccds), nxdef)
                cl.set_default("nx", nxdef)
                nx = cl.get_value("nx", "number of panels in X", 3, 1)
            else:
                nx = 1
        else:
            nx = 1
            ccds = list(ccdinf.keys())

        cl.set_default("pause", 0.0)
        pause = cl.get_value(
            "pause", "time delay to add between" " frame plots [secs]", 0.0, 0.0
        )

        cl.set_default("plotall", False)
        plotall = cl.get_value(
            "plotall", "plot all frames," " regardless of status?", False
        )

        # bias frame (if any)
        bias = cl.get_value(
            "bias",
            "bias frame ['none' to ignore]",
            cline.Fname("bias", hcam.HCAM),
            ignore="none",
        )
        if bias is not None:
            # read the bias frame
            bias = hcam.MCCD.read(bias)
            fprompt = "flat frame ['none' to ignore]"
        else:
            fprompt = "flat frame ['none' is normal choice with no bias]"

        lowlevel = cl.get_value(
            "lowlevel", "bias level lower limit for warnings", 2000.0
        )

        highlevel = cl.get_value(
            "highlevel", "bias level upper limit for warnings", 3500.0
        )

        # flat (if any)
        flat = cl.get_value(
            "flat", fprompt, cline.Fname("flat", hcam.HCAM), ignore="none"
        )
        if flat is not None:
            # read the flat frame
            flat = hcam.MCCD.read(flat)

        # defect file (if any)
        dfct = cl.get_value(
            "defect",
            "defect file ['none' to ignore]",
            cline.Fname("defect", hcam.DFCT),
            ignore="none",
        )
        if dfct is not None:
            # read the defect frame
            dfct = defect.MccdDefect.read(dfct)

        # Get windows from hdriver
        setup = cl.get_value("setup", "display current hdriver window settings", False)

        if setup:
            drurl = cl.get_value(
                "drurl", "URL for driver windows", "http://192.168.1.2:5100"
            )
        else:
            drurl = None

        # colour map to use
        cmap = cl.get_value("cmap", "colour map to use ['none' for mpl default]", "Greys", ignore="none")

        # define the display intensities
        msub = cl.get_value("msub", "subtract median from each window?", True)

        iset = cl.get_value(
            "iset",
            "set intensity a(utomatically)," " d(irectly) or with p(ercentiles)?",
            "a",
            lvals=["a", "d", "p"],
        )
        iset = iset.lower()

        plo, phi = 5, 95
        ilo, ihi = 0, 1000
        if iset == "d":
            ilo = cl.get_value("ilo", "lower intensity limit", 0.0)
            ihi = cl.get_value("ihi", "upper intensity limit", 1000.0)
        elif iset == "p":
            plo = cl.get_value(
                "plo", "lower intensity limit percentile", 5.0, 0.0, 100.0
            )
            phi = cl.get_value(
                "phi", "upper intensity limit percentile", 95.0, 0.0, 100.0
            )

        # region to plot
        for i, cnam in enumerate(ccds):
            nxtot, nytot, nxpad, nypad = ccdinf[cnam]
            if i == 0:
                xmin, xmax = float(-nxpad), float(nxtot + nxpad + 1)
                ymin, ymax = float(-nypad), float(nytot + nypad + 1)
            else:
                xmin = min(xmin, float(-nxpad))
                xmax = max(xmax, float(nxtot + nxpad + 1))
                ymin = min(ymin, float(-nypad))
                ymax = max(ymax, float(nytot + nypad + 1))

        xlo = cl.get_value("xlo", "left-hand X value", xmin, xmin, xmax)
        xhi = cl.get_value("xhi", "right-hand X value", xmax, xmin, xmax)
        ylo = cl.get_value("ylo", "lower Y value", ymin, ymin, ymax)
        yhi = cl.get_value("yhi", "upper Y value", ymax, ymin, ymax)

        # many parameters for profile fits, although most are not
        # plotted by default
        profit = cl.get_value("profit", "do you want profile fits?", False)

        if profit:
            nxf = cl.get_value("nxf", "maximum number of fit panels in X", 3)
            method = cl.get_value(
                "method", "fit method g(aussian) or m(offat)", "m", lvals=["g", "m"]
            )
            if method == "m":
                beta = cl.get_value(
                    "beta", "initial exponent for Moffat fits", 5.0, 0.5, 20.
                )
            else:
                beta = 0.0
            fwhm_min = cl.get_value(
                "fwhm_min", "minimum FWHM to allow [unbinned pixels]", 1.5, 0.01
            )
            fwhm = cl.get_value(
                "fwhm",
                "initial FWHM [unbinned pixels] for profile fits",
                6.0,
                fwhm_min,
            )
            shbox = cl.get_value(
                "shbox",
                "half width of box for initial location"
                " of target [unbinned pixels]",
                11.0,
                2.0,
            )
            smooth = cl.get_value(
                "smooth",
                "FWHM for smoothing for initial object"
                " detection [binned pixels]",
                6.0,
            )
            splot = cl.get_value("splot", "plot outline of search box?", True)
            fhbox = cl.get_value(
                "fhbox",
                "half width of box for profile fit" " [unbinned pixels]",
                21.0,
                3.0,
            )
            hmin = cl.get_value(
                "hmin", "minimum peak height to accept the fit", 50.0
            )
            read = cl.get_value("read", "readout noise, RMS ADU", 3.0)
            gain = cl.get_value("gain", "gain, ADU/e-", 1.0)
            thresh = cl.get_value("thresh", "number of RMS to reject at", 4.0)

    ###############################################################################

    # Phew. We finally have all the inputs and now can now display stuff.

    # track which CCDs have been plotted at least once for the profile fits
    plotted = np.array(len(ccds)*[False])
    not_selected = True
    img_accum = len(ccds)*[None]
    first_plot = True

    # Now onto the animated plots.
    with spooler.data_source(source, resource, first, full=False) as spool:

        nframe, total_time = 0, 0.
        for mccd in spool:

            if server_or_local:
                # Handle the waiting game ...
                give_up, try_again, total_time = spooler.hang_about(
                    mccd, twait, tmax, total_time
                )

                if give_up:
                    print("rtplot stopped")
                    break
                elif try_again:
                    continue

            # Trim the frames: ULTRACAM windowed data has bad columns
            # and rows on the sides of windows closest to the readout
            # which can badly affect reduction. This option strips
            # them.
            if trim:
                hcam.ccd.trim_ultracam(mccd, ncol, nrow)

            # indicate progress
            #            try:
            tstamp = Time(mccd.head["TIMSTAMP"], format="isot", precision=3)
            print(
                "{:d}, utc= {:s} ({:s}), ".format(
                    mccd.head.get("NFRAME",nframe+1),
                    tstamp.iso,
                    "ok" if mccd.head.get("GOODTIME", True) else "nok",
                ),
                end="",
            )
            #            except:
            #   # sometimes times are junk.
            #   print(
            #      '{:d}, utc = {:s}, '.format(
            #           mccd.head['NFRAME'], '2000-01-01 00:00:00.000'), end=''
            #   )

            # accumulate errors
            emessages = []

            # bias level checks
            if lowlevel != 0.0:
                median = mccd.get_num(0).get_num(0).median()
                if median < lowlevel:
                    emessages.append(
                        "** low bias level, median vs limit: {:.1f} vs {:.1f}".format(
                            median, lowlevel
                        )
                    )

            if highlevel != 0.0:
                try:
                    median = mccd.get_num(0).get_num(1).median()
                except:
                    median = mccd.get_num(0).get_num(0).median()

                if median > highlevel:
                    emessages.append(
                        "** high bias level, median vs limit: {:.1f} vs {:.1f}".format(
                            median, lowlevel
                        )
                    )

            if nframe == 0:
                # get the bias and flat into shape first time through

                if bias is not None:
                    # crop the bias on the first frame only
                    bias = bias.crop(mccd)

                if flat is not None:
                    # crop the flat on the first frame only
                    flat = flat.crop(mccd)

            if setup:
                # Get setup windows from hdriver / udriver. Fair bit of
                # error checking needed. 'got_windows' indicates if
                # anything useful found, 'swindows' is a list of
                # (llx,lly,nx,ny) tuples if somthing is found.
                try:
                    r = requests.get(drurl, timeout=0.2)

                    if r.text.strip() == "No valid data available":
                        emessages.append(
                            f"** bad return from hdriver = {r.text.strip()}"
                        )
                        got_windows = False

                    elif r.text.strip() == "fullframe":
                        # to help Stu out a bit, effectively just
                        # ignore this one
                        got_windows = False

                    else:
                        # OK, got something
                        got_windows = True
                        lines = r.text.split("\r\n")
                        xbinh, ybinh, nwinh = lines[0].split()
                        xbinh, ybinh, nwinh = int(xbinh), int(ybinh), int(nwinh)
                        swindows = []
                        for line in lines[1 : nwinh + 1]:
                            llxh, llyh, nxh, nyh = line.split()
                            swindows.append((int(llxh), int(llyh), int(nxh), int(nyh)))

                        if nwinh != len(swindows):
                            emessages.append(
                                f"** expected {nwinh} windows from"
                                " (u/h)driver but got {len(swindows)}"
                            )
                            got_windows = False

                except (
                        requests.exceptions.ConnectionError,
                        socket.timeout,
                        requests.exceptions.Timeout,
                ) as err:
                    emessages.append(" ** hdriver error: {!r}".format(err))
                    got_windows = False

            else:
                got_windows = False

            # wind through the CCDs to display, accumulating stuff
            # to send to the plot manager
            message = ""

            for nc, cnam in enumerate(ccds):
                ccd = mccd[cnam]

                if plotall or ccd.is_data():
                    # "is_data" indicates genuine data as opposed to junk
                    # that results from nskip > 0.
                    plotted[nc] = True

                    # subtract the bias
                    if bias is not None:
                        ccd -= bias[cnam]

                    # divide out the flat
                    if flat is not None:
                        ccd /= flat[cnam]

                    if msub:
                        # subtract median from each window
                        for wind in ccd.values():
                            wind -= wind.median()

                    # set intensity limits
                    if iset == "p":
                        # Set intensities from percentiles
                        if xlo is not None and xhi is not None:
                            pxlo = min(xlo, xhi)
                            pxhi = max(xlo, xhi)
                        else:
                            pxlo, pxhi = None, None
                        if ylo is not None and yhi is not None:
                            pylo = min(ylo, yhi)
                            pyhi = max(ylo, yhi)
                        else:
                            pylo, pyhi = None, None
                        vmin, vmax = ccd.percentile(
                            (plo, phi), pxlo, pxhi, pylo, pyhi
                        )

                    elif iset == "a":
                        # Set intensities from min/max range
                        vmin, vmax = ccd.min(), ccd.max()

                    elif iset == "d":
                        vmin, vmax = dlo, dhi

                    content = [ccd, vmin, vmax]

                    if got_windows:
                        content.append(swindows)
                    else:
                        content.append(None)

                    if dfct is not None and cnam in dfct:
                        content.append(dfct[cnam])
                    else:
                        content.append(None)

                    # Save the content to send to the plot updater
                    img_accum[nc] = content

                    # accumulate string of image scalings
                    if nc:
                        message += ", ccd {:s}: {:.1f}, {:.1f}, exp: {:.4f}".format(
                            cnam, vmin, vmax, mccd.head["EXPTIME"]
                        )
                    else:
                        message += "ccd {:s}: {:.1f}, {:.1f}, exp: {:.4f}".format(
                            cnam, vmin, vmax, mccd.head["EXPTIME"]
                        )

                elif not (profit and not_selected):
                    # If we are in a state of accumulating for profile fit
                    # selection we want each CCD to have something, so
                    # we don't overwrite with None on skipped images
                    # as we normally do
                    img_accum.append(None)

            # Print messages
            print(message)
            for emessage in emessages:
                print(emessage)

            # at this point "img_accum" contains a list of lists, each of
            # which consists of:
            #
            # [ccd, vmin, vmax, swindows, dfct]
            #
            # i.e. the CCD, intensity range, setup windows and defects, or
            # "None" if the CCD was skipped due to nskip

            if profit and not_selected and plotted.all():
                # Finally have at least one proper exposure of all CCDs
                # from which stars can be selected.
                not_selected = False

                # Ready to make first plot of all CCDs
                img_fig, img_axs = setup_images(len(ccds), nx, "Profile fit selection")
                for ax, cnam, content in zip(img_axs, ccds, img_accum):
                    disp_ccd(
                        ax, cnam, xlo, xhi, ylo, yhi, cmap, content, True
                    )
                # Cursor selection routine
                cselect = CursorSelect(img_fig, img_axs, ccds)
                plt.show()

            if not profit or not not_selected:
                # Now carry out the animation
                if first_plot:
                    # one-off setup
                    first_plot = False
                    # create figure and axes
                    img_fig, img_axs = setup_images(len(ccds), nx, "CCD image display")

                    # Create the image plot manager
                    print(len(ccds), len(img_accum))
                    imanager = ImageManager(
                        img_fig, img_axs, ccds, xlo, xhi, ylo, yhi,
                        cmap, img_accum
                    )
                    plt.show(block=False)
                    plt.pause(0.1)

                else:
                    # send updates to image plot manager
                    imanager.update(img_accum)

            if pause > 0.0:
                # pause between frames
                time.sleep(pause)

            # update the frame number
            nframe += 1

# From here is support code not visible outside

def setup_images(nccd, nx, title):
    """
    Sets up the figure and axes for the images display.

    Arguments::

       nccd : int
          number of CCDs to display

       nx : int
          number of panels in the X direction.

    Returns (fig, axs)

    The Figure and Axes, one per CCD
    """

    # Create the figure for the image plot
    fig = plt.figure(title)

    # Define config of images
    ny = nccd // nx if nccd % nx == 0 else nccd // nx + 1

    # Create the axes
    for ind in range(nccd):
        if ind == 0:
            ax0 = fig.add_subplot(ny,nx,ind+1)
            axs = [ax0]
        else:
            axs.append(fig.add_subplot(ny,nx,ind+1,sharex=ax0,sharey=ax0))
    return (fig, axs)


class ImageManager:
    """Class to control the image animation

    Basic idea is that initialising it stores all the very many inputs
    as attributes and creates the plot, then the update method
    is used to plot successive frames.
    """

    def __init__(
            self, fig, axs, ccds, xlo, xhi, ylo, yhi, cmap, accum
    ):
        """
        Initialises the plot. Arguments:

          fig : Figure
             the figure containing the images

          axs : iterable(Axes)
             the associated Axes, one per CCD being displayed

          ccds : list of strings
             CCD names to plot

          xlo : float
             left-hand limit of region to determine percentiles and for display

          xhi : float
             right-hand limit of region to display

          ylo : float
             lower limit of region to display

          yhi : float
             upper limit of region to display

          cmap : str  | None
             Matplotlib colour map. None gives default


          accum : list of lists
             one list per CCD being displayed. Contains the information
             required for the first plot. Per CCD the list should be:
             [ccd, vmin, vmax, swindows, dfcts] or None if the CCD is
             being skipped. swindows -- setup windows -- can be None.
             dfcts -- defects -- can also be None.
        """

        assert(len(axs) == len(ccds))
        assert(len(accum) == len(ccds))

        # Save the inputs

        # first stuff to do with the mpl figures
        self.fig = fig
        self.axs = axs
        self.cnv = fig.canvas
        self._bg = None

        # rtplot inputs
        self.ccds = ccds
        self.xlo = xlo
        self.xhi = xhi
        self.ylo = ylo
        self.yhi = yhi
        self.cmap = cmap

        # list of dictionaries of artists for each image panel
        self.artists = []

        # now we actually create the artists
        for ax, cnam, content in zip(self.axs, self.ccds, accum):
            if content is None:
                # do nothing much other than add a placeholder
                self.artists.append(None)
            else:
                # plot the CCD, return with the animated artists
                self.artists.append(
                    self._disp_ccd(ax, cnam, content)
                )

        # grab the background on every draw
        self.cid = self.cnv.mpl_connect("draw_event", self.on_draw)

    def on_draw(self, event):
        """Callback to register with 'draw_event'."""
        cnv = self.cnv
        if event is not None and event.canvas != cnv:
            raise RuntimeError
        self._bg = cnv.copy_from_bbox(cnv.figure.bbox)
        self._draw_animated()

    def _draw_animated(self):
        # draw all of the animated artists for the image plot
        for artists in self.artists:
            if artists is not None:
                for alist in artists.values():
                    for artist in alist:
                        self.fig.draw_artist(artist)

    def update(self, accum):
        """updating routine, Pass it accum which contains a list of lists
        for each image plot sub-panel with enough information to update them.

        """

        # now update / create the artists
        lartists = []
        for ax, cnam, content, artists in zip(self.axs, self.ccds, accum, self.artists):
            if content is None:
                # just pass old artists through
                lartists.append(artists)
            else:
                # plot the CCD, return with the animated artists
                lartists.append(self._disp_ccd(ax, cnam, content, artists))

        self.artists = lartists

        cnv = self.cnv
        fig = self.fig
        if self._bg is None:
            self.on_draw(None)
        else:
            # restore the background
            cnv.restore_region(self._bg)
            self._draw_animated()
            cnv.blit(fig.bbox)
        cnv.flush_events()

    def _disp_ccd(self, ax, cnam, content, artists=None):
        """Displays a CCD ccd, name cnam, in Axes ax.

        If "artists" is None, a dictionary will be created and
        returned containing various lists of animated artists.
        Otherwise it is assumed to be such a list resulting from an
        earlier run and will be updated.

        """


        if artists is None:

            # in this case we are setting up for the first time
            artists = disp_ccd(
                ax, cnam,
                self.xlo, self.xhi, self.ylo, self.yhi, self.cmap,
                content, True
            )

            # need to re-draw to avoid irritating distorted image
            self.cnv.draw()

        else:

            # unpack the new content
            ccd, vmin, vmax, swindows, dfct = content

            # this is the "usual" post-setup case where we just update
            # the artists

            # the CCD window data
            for wind, img in zip(ccd.values(), artists['windows']):
                img.set_data(wind.data)
                img.set_clim(vmin, vmax)

            # defects don't change so nothing done to them.

            # the setup windows. Can change in number as well as size
            # so delete old ones (if there are any) and re-create each
            # time remove old setup windows
            swins = artists['swindows']
            for artist in swins:
                artist.remove()
            artists['swindows'] = []

            if swindows is not None:

                # draw new ones, keeping refs to objects for next time
                swins = []
                for llxh, llyh, nxh, nyh in swindows:
                    box, = ax.plot(
                        [llxh-0.5, llxh+nxh-0.5, llxh+nxh-0.5, llxh-0.5, llxh-0.5],
                        [llyh-0.5, llyh-0.5, llyh+nyh-0.5, llyh+nxh-0.5, llyh-0.5],
                        '--', color=COL_SETUP, animated=True
                    )
                    swins.append(box)
                artists['swindows'] = swins

        return artists


def disp_ccd(ax, cnam, xlo, xhi, ylo, yhi, cmap, content, animated):
    """Displays a CCD ccd, name cnam, in Axes ax.

    If used for movie-style display, set animated=True
    In this case a dictionary of animated artists will be returned
    """

    # unpack the new content
    ccd, vmin, vmax, swindows, dfct = content

    if animated:
        artists = {}
        wins = artists['windows'] = []

    for wnam, wind in ccd.items():
        left, right, bottom, top = wind.extent()

        # Display the image of each window
        img = ax.imshow(
            wind.data,
            extent=(left, right, bottom, top),
            aspect="equal",
            origin="lower",
            cmap=cmap,
            interpolation="nearest",
            vmin=vmin,
            vmax=vmax,
            animated=animated
        )
        if animated:
            wins.append(img)

        # Plot boundary on window (fixed)
        ax.plot(
            [left, right, right, left, left],
            [bottom, bottom, top, top, bottom],
            color=Params["win.box.col"],
        )

        # Label them (fixed)
        ax.text(
            left - 3,
            bottom - 3,
            wnam,
            fontsize=Params["win.label.fs"],
            color=Params["win.label.col"],
            ha="right",
            va="top",
            clip_on=True,
        )

        # plot defects
        if dfct is None:
            dfcts = []
        else:
            dfcts = hcam.mpl.pCcdDefect(ax, dfct, True).values()
        if animated:
            artists['defects'] = dfcts

        # plot setup windows
        if swindows is None:
            swins = []
        else:
            swins = []
            for llxh, llyh, nxh, nyh in swindows:
                box, = ax.plot(
                    [llxh-0.5, llxh+nxh-0.5, llxh+nxh-0.5, llxh-0.5, llxh-0.5],
                    [llyh-0.5, llyh-0.5, llyh+nyh-0.5, llyh+nxh-0.5, llyh-0.5],
                    '--', color=COL_SETUP, animated=True
                )
                swins.append(box)

        if animated:
            artists['swindows'] = swins

        # Plot outermost border of CCD (fixed)
        ax.plot(
            [0.5, ccd.nxtot + 0.5, ccd.nxtot + 0.5, 0.5, 0.5],
            [0.5, 0.5, ccd.nytot + 0.5, ccd.nytot + 0.5, 0.5],
            color=Params["ccd.box.col"],
        )

        # Set title and axis labels (fixed)
        ax.set_title(
            f'CCD {cnam}',
            color=Params["axis.label.col"], fontsize=Params["axis.label.fs"]
        )

        # set axis limits
        ax.set_xlim(xlo, xhi)
        ax.set_ylim(ylo, yhi)
        ax.set_aspect('equal')
        for tick in ax.get_yticklabels():
            tick.set_rotation(90)

class FitManager:
    """Class to control the profile fit animation
    """

    def __init__(
            self, fig, axs, stars, accum
    ):
        """
        Initialises the plot. Arguments:

          fig : Figure
             the figure containing the fits

          axs : iterable(Axes)
             the associated Axes, one per profile fit

          stars : list of strings
             CCD names to plot

          accum : list of lists
             one list per CCD being displayed. Contains the information
             required for the first plot. Per CCD the list should be:
             [ccd, vmin, vmax, swindows, dfcts] or None if the CCD is
             being skipped. swindows -- setup windows -- can be None.
             dfcts -- defects -- can also be None.
        """

        assert(len(axs) == len(ccds))
        assert(len(accum) == len(ccds))

        # Save the inputs

        # first stuff to do with the mpl figures
        self.fig = ig
        self.axs = axs
        self.cnv = fig.canvas
        self._bg = None

        # rtplot inputs
        self.ccds = ccds
        self.xlo = xlo
        self.xhi = xhi
        self.ylo = ylo
        self.yhi = yhi
        self.cmap = cmap

        # list of dictionaries of artists for each image panel
        self.artists = []

        # now we actually create the artists
        for ax, cnam, content in zip(self.axs, self.ccds, accum):
            if content is None:
                # do nothing much other than add a placeholder
                self.artists.append(None)
            else:
                # plot the CCD, return with the animated artists
                self.artists.append(
                    self._disp_ccd(ax, cnam, content)
                )

        # grab the background on every draw
        self.cid = self.cnv.mpl_connect("draw_event", self.on_draw)

    def on_draw(self, event):
        """Callback to register with 'draw_event'."""
        cnv = self.cnv
        if event is not None and event.canvas != cnv:
            raise RuntimeError
        self._bg = cnv.copy_from_bbox(cnv.figure.bbox)
        self._draw_animated()

    def _draw_animated(self):
        # draw all of the animated artists for the image plot
        for artists in self.artists:
            if artists is not None:
                for alist in artists.values():
                    for artist in alist:
                        self.fig.draw_artist(artist)

    def update(self, accum):
        """updating routine, Pass it accum which contains a list of lists
        for each image plot sub-panel with enough information to update them.

        """

        # now update / cfreate the artists
        artists = []
        for ax, cnam, content, artists in zip(self.axs, self.ccds, accum, self.artists):
            if content is None:
                # just pass old artists through
                artists.append(artists)
            else:
                # plot the CCD, return with the animated artists
                artists.append(
                    self._disp_ccd(ax, cnam, content, artists)
                )
        self.artists = artists

        cnv = self.cnv
        fig = self.fig
        if self._bg is None:
            self.on_draw(None)
        else:
            # restore the background
            cnv.restore_region(self._bg)
            self._draw_animated()
            cnv.blit(fig.bbox)
        cnv.flush_events()


    def _disp_ccd(self, ax, cnam, content, artists=None):
        """Displays a CCD ccd, name cnam, in Axes ax.

        If "artists" is None, a dictionary will be created and
        returned containing various lists of animated artists.
        Otherwise it is assumed to be such a list resulting from an
        earlier run and will be updated.

        """

        # unpack the new content
        ccd, vmin, vmax, swindows, dfct = content

        if artists is None:

            # in this case we are setting up for the first time
            artists = {}
            wins = artists['windows'] = []
            for wnam, wind in ccd.items():
                left, right, bottom, top = wind.extent()

                # Display the images of each window. save them
                # since it is animated
                wins.append(
                    ax.imshow(
                        wind.data,
                        extent=(left, right, bottom, top),
                        aspect="equal",
                        origin="lower",
                        cmap=self.cmap,
                        interpolation="nearest",
                        vmin=vmin,
                        vmax=vmax,
                        animated=True
                    )
                )

                # Plot boundary on window (fixed)
                ax.plot(
                    [left, right, right, left, left],
                    [bottom, bottom, top, top, bottom],
                    color=Params["win.box.col"],
                )

                # Label them (fixed)
                ax.text(
                    left - 3,
                    bottom - 3,
                    wnam,
                    fontsize=Params["win.label.fs"],
                    color=Params["win.label.col"],
                    ha="right",
                    va="top",
                    clip_on=True,
                )

            # plot defects
            if dfct is None:
                artists['defects'] = []
            else:
                artists['defects'] = hcam.mpl.pCcdDefect(ax, dfct, True).values()

            # plot setup windows
            if swindows is None:
                artists['swindows'] = []
            else:
                swins = []
                for llxh, llyh, nxh, nyh in swindows:
                    box, = ax.plot(
                        [llxh-0.5, llxh+nxh-0.5, llxh+nxh-0.5, llxh-0.5, llxh-0.5],
                        [llyh-0.5, llyh-0.5, llyh+nyh-0.5, llyh+nxh-0.5, llyh-0.5],
                        '--', color=COL_SETUP, animated=True
                    )
                    swins.append(box)
                artists['swindows'] = swins

            # Plot outermost border of CCD (fixed)
            ax.plot(
                [0.5, ccd.nxtot + 0.5, ccd.nxtot + 0.5, 0.5, 0.5],
                [0.5, 0.5, ccd.nytot + 0.5, ccd.nytot + 0.5, 0.5],
                color=Params["ccd.box.col"],
            )

            # Set title and axis labels (fixed)
            ax.set_title(
                f'CCD {cnam}',
                color=Params["axis.label.col"], fontsize=Params["axis.label.fs"]
            )

            # set axis limits
            ax.set_xlim(self.xlo, self.xhi)

            ax.set_ylim(self.ylo, self.yhi)
            ax.set_aspect('equal')
            for tick in ax.get_yticklabels():
                tick.set_rotation(90)

            # need to re-draw to avoid irritating distorted image in
            cnv = self.cnv
            cnv.draw()

        else:

            # this is the "usual" post-setup case where we just update
            # the artists

            # the CCD window data
            for wind, img in zip(ccd.values(), artists['windows']):
                img.set_data(wind.data)
                img.set_clim(vmin, vmax)

            # defects don't change so nothing done to them.

            # the setup windows. Can change in number as well as size
            # so delete old ones (if there are any) and re-create each
            # time remove old setup windows
            swins = artists['swindows']
            for artist in swins:
                artist.remove()
            artists['swindows'] = []

            if swindows is not None:

                # draw new ones, keeping refs to objects for next time
                swins = []
                for llxh, llyh, nxh, nyh in swindows:
                    box, = ax.plot(
                        [llxh-0.5, llxh+nxh-0.5, llxh+nxh-0.5, llxh-0.5, llxh-0.5],
                        [llyh-0.5, llyh-0.5, llyh+nyh-0.5, llyh+nxh-0.5, llyh-0.5],
                        '--', color=COL_SETUP, animated=True
                    )
                    swins.append(box)
                artists['swindows'] = swins

        return artists

class CursorSelect():
    """
    Avoids spurious panning clicks from being registered
    """

    def __init__(self, fig, axs, ccds):
        self.cnv = fig.canvas
        self.axs = axs
        self.ccds = ccds

        self.press = False
        self.move = False
        self.c1=self.cnv.mpl_connect('button_press_event', self._onpress)
        self.c2=self.cnv.mpl_connect('button_release_event', self._onrelease)
        self.c3=self.cnv.mpl_connect('motion_notify_event', self._onmove)

        print('\nclick to select stars, q to exit and start animation')

    def _onclick(self, event):
        """
        Where stuff is done
        """

        if event.inaxes is not None:
            for ax, cnam in zip(self.axs,self.ccds):
                if event.inaxes == ax:
                    print(f'Clicked inside CCD {cnam} at x,y = {event.xdata}, {event.ydata}')

    def _onpress(self,event):
        self.press = True

    def _onmove(self,event):
        if self.press:
            self.move = True

    def _onrelease(self,event):
        # only call onclick in special circumstances
        if self.press and not self.move:
            self._onclick(event)
        self.press = False
        self.move = False
